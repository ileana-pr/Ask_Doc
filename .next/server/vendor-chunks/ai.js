"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTJEOztBQ0FwRCxJQUFNRyx3QkFBd0JDLE9BQU9DLEdBQUEsQ0FBSTtBQUN6QyxJQUFNQyxzQ0FBc0MsS0FBSzs7QURHeEQsU0FBU0MsMEJBQTBCQyxLQUFBO0lBQ2pDLE9BQU8sQ0FBQyxDQUNOQSxDQUFBQSxTQUNBLE9BQU9BLFVBQVUsWUFDakIsVUFBVUEsU0FDVkEsTUFBTUMsSUFBQSxLQUFTTixxQkFBQTtBQUVuQjtBQUVBLFNBQVNPLHNCQUNQRixLQUFBO0lBRUEsSUFBSSxDQUFDRCwwQkFBMEJDLFFBQVE7UUFDckMsTUFBTSxJQUFJRyxNQUNSO0lBRUo7QUFDRjtBQUVBLFNBQVNDLGtCQUFrQkosS0FBQTtJQUN6QixNQUFNSyxlQUFlTiwwQkFBMEJDO0lBRS9DLElBQUksQ0FBQ0ssZ0JBQWdCLE9BQU9MLFVBQVUsYUFBYTtRQUNqRCxNQUFNLElBQUlHLE1BQ1I7SUFFSjtJQUVBLE9BQU9FO0FBQ1Q7QUFnQ08sU0FBU0Msb0JBQ2RDLGVBQUE7SUFFQUwsc0JBQXNCSztJQUV0QixPQUFPO1FBQ0wsQ0FBQ1gsT0FBT1ksYUFBYTtZQUNuQixJQUFJQyxNQUNGRjtZQUNGLElBQUlHLE9BQU9ELElBQUlDLElBQUE7WUFDZixJQUFJQyxPQUFPO1lBQ1gsSUFBSUMsVUFBVTtZQUVkLE9BQU87Z0JBQ0wsTUFBTUM7b0JBQ0osSUFBSUYsTUFBTSxPQUFPO3dCQUFFWCxPQUFPVTt3QkFBTUMsTUFBTTtvQkFBSztvQkFFM0NGLE1BQU0sTUFBTUE7b0JBRVosSUFBSSxPQUFPQSxJQUFJSyxLQUFBLEtBQVUsYUFBYTt3QkFDcEMsTUFBTUwsSUFBSUssS0FBQTtvQkFDWjtvQkFDQSxJQUFJLFVBQVVMLE9BQU9BLElBQUlNLElBQUEsRUFBTTt3QkFDN0IsSUFBSU4sSUFBSU0sSUFBQSxFQUFNOzRCQUNaLE9BQVFOLElBQUlNLElBQUEs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SUFDbEI7SUFFQSxPQUFPK0U7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2Fza19kb2MvLi4vc2hhcmVkLWNsaWVudC9zdHJlYW1hYmxlLnRzeD9lMThiIiwid2VicGFjazovL2Fza19kb2MvLi4vY29uc3RhbnRzLnRzP2FiNzIiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9zaGFyZWQtY2xpZW50L2NvbnRleHQudHN4P2NiM2YiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi91dGlsL2lzLWZ1bmN0aW9uLnRzPzJkNGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU1RSRUFNQUJMRV9WQUxVRV9UWVBFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5mdW5jdGlvbiBoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgcmV0dXJuICEhKFxuICAgIHZhbHVlICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICd0eXBlJyBpbiB2YWx1ZSAmJlxuICAgIHZhbHVlLnR5cGUgPT09IFNUUkVBTUFCTEVfVkFMVUVfVFlQRVxuICApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJlYW1hYmxlVmFsdWUoXG4gIHZhbHVlOiB1bmtub3duLFxuKTogYXNzZXJ0cyB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICBpZiAoIWhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLicsXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0cmVhbWFibGVWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIGNvbnN0IGhhc1NpZ25hdHVyZSA9IGhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWUpO1xuXG4gIGlmICghaGFzU2lnbmF0dXJlICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuJyxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGhhc1NpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdGFrZXMgYSBzdHJlYW1hYmxlIHZhbHVlIGNyZWF0ZWQgdmlhIHRoZSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCkudmFsdWVgIEFQSSxcbiAqIGFuZCByZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbnNpZGUgeW91ciBBSSBhY3Rpb246XG4gKlxuICogYXN5bmMgZnVuY3Rpb24gYWN0aW9uKCkge1xuICogICAndXNlIHNlcnZlcidcbiAqICAgY29uc3Qgc3RyZWFtYWJsZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpO1xuICpcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMSk7XG4gKiAgIHN0cmVhbWFibGUudXBkYXRlKDIpO1xuICogICBzdHJlYW1hYmxlLmRvbmUoMyk7XG4gKiAgIC8vIC4uLlxuICogICByZXR1cm4gc3RyZWFtYWJsZS52YWx1ZTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCB0byByZWFkIHRoZSB2YWx1ZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gYXdhaXQgYWN0aW9uKClcbiAqIGZvciBhd2FpdCAoY29uc3QgdiBvZiByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHtcbiAqICAgY29uc29sZS5sb2codilcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgbG9ncyBvdXQgMSwgMiwgMyBvbiBjb25zb2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmVhbWFibGVWYWx1ZTxUID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZTogU3RyZWFtYWJsZVZhbHVlPFQ+LFxuKTogQXN5bmNJdGVyYWJsZTxUIHwgdW5kZWZpbmVkPiB7XG4gIGFzc2VydFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIGxldCByb3c6IFN0cmVhbWFibGVWYWx1ZTxUPiB8IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQ+PiA9XG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZTtcbiAgICAgIGxldCBjdXJyID0gcm93LmN1cnI7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IGluaXRpYWwgPSB0cnVlO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm4geyB2YWx1ZTogY3VyciwgZG9uZTogdHJ1ZSB9O1xuXG4gICAgICAgICAgcm93ID0gYXdhaXQgcm93O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiByb3cuZXJyb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyByb3cuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnY3VycicgaW4gcm93IHx8IHJvdy5kaWZmKSB7XG4gICAgICAgICAgICBpZiAocm93LmRpZmYpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChyb3cuZGlmZlswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHBhdGNoOiBjYW4gb25seSBhcHBlbmQgdG8gc3RyaW5nIHR5cGVzLiBUaGlzIGlzIGEgYnVnIGluIHRoZSBBSSBTREsuJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChjdXJyIGFzIHN0cmluZykgPSBjdXJyICsgcm93LmRpZmZbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyciA9IHJvdy5jdXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBlbWl0dGVkIHsgZG9uZTogdHJ1ZSB9IHdvbid0IGJlIHVzZWQgYXMgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBieSB0aGUgZm9yIGF3YWl0Li4ub2Ygc3ludGF4LlxuICAgICAgICAgICAgaWYgKCFyb3cubmV4dCkge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VycixcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXJvdy5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogY3VycixcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ID0gcm93Lm5leHQ7XG4gICAgICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCBjaHVuayBhbmQgdGhlcmUgaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZSB5ZXQuXG4gICAgICAgICAgICAgIC8vIExldCdzIHNraXAgdGhpcyBvbmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIGB1c2VTdHJlYW1hYmxlVmFsdWVgIGlzIGEgUmVhY3QgaG9vayB0aGF0IHRha2VzIGEgc3RyZWFtYWJsZSB2YWx1ZSBjcmVhdGVkIHZpYSB0aGUgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpLnZhbHVlYCBBUEksXG4gKiBhbmQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSwgZXJyb3IsIGFuZCBwZW5kaW5nIHN0YXRlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb25zdW1pbmcgc3RyZWFtYWJsZSB2YWx1ZXMgcmVjZWl2ZWQgZnJvbSBhIGNvbXBvbmVudCdzIHByb3BzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gTXlDb21wb25lbnQoeyBzdHJlYW1hYmxlVmFsdWUgfSkge1xuICogICBjb25zdCBbZGF0YSwgZXJyb3IsIHBlbmRpbmddID0gdXNlU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG4gKlxuICogICBpZiAocGVuZGluZykgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcbiAqICAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5FcnJvcjoge2Vycm9yLm1lc3NhZ2V9PC9kaXY+O1xuICpcbiAqICAgcmV0dXJuIDxkaXY+RGF0YToge2RhdGF9PC9kaXY+O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdHJlYW1hYmxlVmFsdWU8VCA9IHVua25vd24sIEVycm9yID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZT86IFN0cmVhbWFibGVWYWx1ZTxUPixcbik6IFtkYXRhOiBUIHwgdW5kZWZpbmVkLCBlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQsIHBlbmRpbmc6IGJvb2xlYW5dIHtcbiAgY29uc3QgW2N1cnIsIHNldEN1cnJdID0gdXNlU3RhdGU8VCB8IHVuZGVmaW5lZD4oXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5jdXJyIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPEVycm9yIHwgdW5kZWZpbmVkPihcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmVycm9yIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gISFzdHJlYW1hYmxlVmFsdWUubmV4dCA6IGZhbHNlLFxuICApO1xuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSByZXR1cm47XG5cbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAgICBpZiAoc3RyZWFtYWJsZVZhbHVlLm5leHQpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRDdXJyKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHNldEVycm9yKGUgYXMgRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbc3RyZWFtYWJsZVZhbHVlXSk7XG5cbiAgcmV0dXJuIFtjdXJyLCBlcnJvciwgcGVuZGluZ107XG59XG4iLCJleHBvcnQgY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcigndWkuc3RyZWFtYWJsZS52YWx1ZScpO1xuZXhwb3J0IGNvbnN0IERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FID0gMTUgKiAxMDAwO1xuIiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICogYXMganNvbmRpZmZwYXRjaCBmcm9tICdqc29uZGlmZnBhdGNoJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi8uLi91dGlsL2lzLWZ1bmN0aW9uJztcbmltcG9ydCB0eXBlIHtcbiAgQUlQcm92aWRlcixcbiAgSW5mZXJBY3Rpb25zLFxuICBJbmZlckFJU3RhdGUsXG4gIEluZmVyVUlTdGF0ZSxcbiAgSW50ZXJuYWxBSVByb3ZpZGVyUHJvcHMsXG4gIFZhbHVlT3JVcGRhdGVyLFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IEludGVybmFsVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcbmNvbnN0IEludGVybmFsQUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDx1bmRlZmluZWQgfCBhbnk+KHVuZGVmaW5lZCk7XG5jb25zdCBJbnRlcm5hbEFjdGlvblByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcbmNvbnN0IEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBJbnRlcm5hbEFJUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgaW5pdGlhbFVJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZVBhdGNoLFxuICB3cmFwcGVkQWN0aW9ucyxcbiAgd3JhcHBlZFN5bmNVSVN0YXRlLFxufTogSW50ZXJuYWxBSVByb3ZpZGVyUHJvcHMpIHtcbiAgaWYgKCEoJ3VzZScgaW4gUmVhY3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBSZWFjdCB2ZXJzaW9uLicpO1xuICB9XG5cbiAgY29uc3QgdWlTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxVSVN0YXRlKTtcbiAgY29uc3Qgc2V0VUlTdGF0ZSA9IHVpU3RhdGVbMV07XG5cbiAgY29uc3QgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoID0gaW5pdGlhbEFJU3RhdGVQYXRjaFxuICAgID8gKFJlYWN0IGFzIGFueSkudXNlKGluaXRpYWxBSVN0YXRlUGF0Y2gpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGluaXRpYWxBSVN0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCkge1xuICAgICAgcmV0dXJuIGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoaW5pdGlhbEFJU3RhdGUpLFxuICAgICAgICByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2gsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbEFJU3RhdGU7XG4gIH0sIFtpbml0aWFsQUlTdGF0ZSwgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoXSk7XG5cbiAgY29uc3QgYWlTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxBSVN0YXRlKTtcbiAgY29uc3Qgc2V0QUlTdGF0ZSA9IGFpU3RhdGVbMV07XG4gIGNvbnN0IGFpU3RhdGVSZWYgPSBSZWFjdC51c2VSZWYoYWlTdGF0ZVswXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhaVN0YXRlUmVmLmN1cnJlbnQgPSBhaVN0YXRlWzBdO1xuICB9LCBbYWlTdGF0ZVswXV0pO1xuXG4gIGNvbnN0IGNsaWVudFdyYXBwZWRBY3Rpb25zID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyh3cmFwcGVkQWN0aW9ucykubWFwKChba2V5LCBhY3Rpb25dKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGFzeW5jICguLi5hcmdzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFpU3RhdGVTbmFwc2hvdCA9IGFpU3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IFthaVN0YXRlRGVsdGEsIHJlc3VsdF0gPSBhd2FpdCBhY3Rpb24oXG4gICAgICAgICAgICAgIGFpU3RhdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IGF3YWl0IGFpU3RhdGVEZWx0YTtcbiAgICAgICAgICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhaVN0YXRlWzFdKFxuICAgICAgICAgICAgICAgICAganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAgICAgICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgXSksXG4gICAgICApLFxuICAgIFt3cmFwcGVkQWN0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgY2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9uID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCF3cmFwcGVkU3luY1VJU3RhdGUpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgdWlTdGF0ZV0gPSBhd2FpdCB3cmFwcGVkU3luY1VJU3RhdGUhKFxuICAgICAgICBhaVN0YXRlU25hcHNob3QsXG4gICAgICApO1xuXG4gICAgICBpZiAodWlTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldFVJU3RhdGUodWlTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEFpU3RhdGUgPSBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoYWlTdGF0ZVNuYXBzaG90KSxcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QUlTdGF0ZShwYXRjaGVkQWlTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3dyYXBwZWRTeW5jVUlTdGF0ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPEludGVybmFsQUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXthaVN0YXRlfT5cbiAgICAgIDxJbnRlcm5hbFVJU3RhdGVQcm92aWRlci5Qcm92aWRlciB2YWx1ZT17dWlTdGF0ZX0+XG4gICAgICAgIDxJbnRlcm5hbEFjdGlvblByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXtjbGllbnRXcmFwcGVkQWN0aW9uc30+XG4gICAgICAgICAgPEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlci5Qcm92aWRlclxuICAgICAgICAgICAgdmFsdWU9e2NsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbn1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9JbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgICAgIDwvSW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlcj5cbiAgICAgIDwvSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgPC9JbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpIHtcbiAgdHlwZSBUID0gSW5mZXJVSVN0YXRlPEFJLCBhbnk+O1xuXG4gIGNvbnN0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dDxcbiAgICBbVCwgKHY6IFQgfCAoKHZfOiBUKSA9PiBUKSkgPT4gdm9pZF0gfCBudWxsIHwgdW5kZWZpbmVkXG4gID4oSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIpO1xuICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bpbml0aWFsVUlTdGF0ZWAgbXVzdCBiZSBwcm92aWRlZCB0byBgY3JlYXRlQUlgIG9yIGA8QUk+YCcsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8vIFRPRE86IEhvdyBkbyB3ZSBhdm9pZCBjYXVzaW5nIGEgcmUtcmVuZGVyIHdoZW4gdGhlIEFJIHN0YXRlIGNoYW5nZXMgYnV0IHlvdVxuLy8gYXJlIG9ubHkgbGlzdGVuaW5nIHRvIGEgc3BlY2lmaWMga2V5PyBXZSBuZWVkIHVzZVNFUyBwZXJoYXBzP1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IFtcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuICAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPEluZmVyQUlTdGF0ZTxBSSwgYW55Pj4pID0+IHZvaWQsXG5dO1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IFtcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldLFxuICAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT4pID0+IHZvaWQsXG5dO1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgdHlwZSBUID0gSW5mZXJBSVN0YXRlPEFJLCBhbnk+O1xuXG4gIGNvbnN0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dDxcbiAgICBbVCwgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxUPikgPT4gdm9pZF0gfCBudWxsIHwgdW5kZWZpbmVkXG4gID4oSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIpO1xuICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VBSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bpbml0aWFsQUlTdGF0ZWAgbXVzdCBiZSBwcm92aWRlZCB0byBgY3JlYXRlQUlgIG9yIGA8QUk+YCcsXG4gICAgKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggPj0gMSAmJiB0eXBlb2Ygc3RhdGVbMF0gIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1doZW4gdXNpbmcgYHVzZUFJU3RhdGVgIHdpdGggYSBrZXksIHRoZSBBSSBzdGF0ZSBtdXN0IGJlIGFuIG9iamVjdC4nLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICBjb25zdCBzZXR0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgPyBzdGF0ZVsxXVxuICAgICAgOiAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPFQ+KSA9PiB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVbMV0ocyA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLnMsIFtrZXldOiBuZXdTdGF0ZShzW2tleV0pIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlWzFdKHsgLi4uc3RhdGVbMF0sIFtrZXldOiBuZXdTdGF0ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgW2tleV0sXG4gICk7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbc3RhdGVbMF1bYXJnc1swXV0sIHNldHRlcl07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbnM8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpIHtcbiAgdHlwZSBUID0gSW5mZXJBY3Rpb25zPEFJLCBhbnk+O1xuXG4gIGNvbnN0IGFjdGlvbnMgPSBSZWFjdC51c2VDb250ZXh0PFQ+KEludGVybmFsQWN0aW9uUHJvdmlkZXIpO1xuICByZXR1cm4gYWN0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNVSVN0YXRlKCkge1xuICBjb25zdCBzeW5jVUlTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8KCkgPT4gUHJvbWlzZTx2b2lkPj4oXG4gICAgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLFxuICApO1xuXG4gIGlmIChzeW5jVUlTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZVN5bmNVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cblxuICByZXR1cm4gc3luY1VJU3RhdGU7XG59XG5cbmV4cG9ydCB7IHVzZUFJU3RhdGUgfTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiJdLCJuYW1lcyI6WyJzdGFydFRyYW5zaXRpb24iLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VTdGF0ZSIsIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsIlN5bWJvbCIsImZvciIsIkRFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FIiwiaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSIsInZhbHVlIiwidHlwZSIsImFzc2VydFN0cmVhbWFibGVWYWx1ZSIsIkVycm9yIiwiaXNTdHJlYW1hYmxlVmFsdWUiLCJoYXNTaWduYXR1cmUiLCJyZWFkU3RyZWFtYWJsZVZhbHVlIiwic3RyZWFtYWJsZVZhbHVlIiwiYXN5bmNJdGVyYXRvciIsInJvdyIsImN1cnIiLCJkb25lIiwiaW5pdGlhbCIsIm5leHQiLCJlcnJvciIsImRpZmYiLCJ1c2VTdHJlYW1hYmxlVmFsdWUiLCJzZXRDdXJyIiwic2V0RXJyb3IiLCJwZW5kaW5nIiwic2V0UGVuZGluZyIsImNhbmNlbGxlZCIsIml0ZXJhdG9yIiwiZSIsIlJlYWN0IiwianNvbmRpZmZwYXRjaCIsImlzRnVuY3Rpb24iLCJqc3giLCJJbnRlcm5hbFVJU3RhdGVQcm92aWRlciIsImNyZWF0ZUNvbnRleHQiLCJJbnRlcm5hbEFJU3RhdGVQcm92aWRlciIsIkludGVybmFsQWN0aW9uUHJvdmlkZXIiLCJJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJjaGlsZHJlbiIsImluaXRpYWxVSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZVBhdGNoIiwid3JhcHBlZEFjdGlvbnMiLCJ3cmFwcGVkU3luY1VJU3RhdGUiLCJ1aVN0YXRlIiwic2V0VUlTdGF0ZSIsInJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCIsInVzZSIsInVzZU1lbW8iLCJwYXRjaCIsImNsb25lIiwiYWlTdGF0ZSIsInNldEFJU3RhdGUiLCJhaVN0YXRlUmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImNsaWVudFdyYXBwZWRBY3Rpb25zIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwia2V5IiwiYWN0aW9uIiwiYXJncyIsImFpU3RhdGVTbmFwc2hvdCIsImFpU3RhdGVEZWx0YSIsInJlc3VsdCIsImRlbHRhIiwiY2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9uIiwicGF0Y2hlZEFpU3RhdGUiLCJQcm92aWRlciIsInVzZVVJU3RhdGUiLCJzdGF0ZSIsInVzZUNvbnRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJ1c2VBSVN0YXRlIiwibGVuZ3RoIiwic2V0dGVyIiwidXNlQ2FsbGJhY2siLCJuZXdTdGF0ZSIsInMiLCJ1c2VBY3Rpb25zIiwiYWN0aW9ucyIsInVzZVN5bmNVSVN0YXRlIiwic3luY1VJU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidModelIdError: () => (/* binding */ InvalidModelIdError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData2),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   convertDataContentToBase64String: () => (/* binding */ convertDataContentToBase64String),\n/* harmony export */   convertDataContentToUint8Array: () => (/* binding */ convertDataContentToUint8Array),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   convertUint8ArrayToText: () => (/* binding */ convertUint8ArrayToText),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseComplexResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parseComplexResponse),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parseStreamPart),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(action-browser)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/@opentelemetry/api/build/esm/index.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventsource-parser */ \"(action-browser)/./node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name9 in all)\n    __defProp(target, name9, { get: all[name9], enumerable: true });\n};\n\n// streams/index.ts\n\n\n\n// util/retry-with-exponential-backoff.ts\n\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n  return new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name, message });\n    this[_a] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isRetryError(error) {\n    return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      reason: this.reason,\n      lastError: this.lastError,\n      errors: this.errors\n    };\n  }\n};\n_a = symbol;\n\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationName,\n  telemetry\n}) {\n  return {\n    \"operation.name\": `${operationName}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`\n  };\n}\n\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a9;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // special telemetry information\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId,\n    // add metadata as attributes:\n    ...Object.entries((_a9 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a9 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// core/telemetry/get-tracer.ts\n\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name9, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// core/telemetry/get-tracer.ts\nvar testTracer = void 0;\nfunction getTracer({ isEnabled }) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (testTracer) {\n    return testTracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.trace.getTracer(\"ai\");\n}\n\n// core/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name9,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name9, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          });\n          span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR,\n            message: error.message\n          });\n        } else {\n          span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR });\n        }\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\n\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value === void 0) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  var _a9;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a9 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a9 : false });\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationName: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const { embedding, usage, rawResponse } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a10;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a10 = modelResponse.usage) != null ? _a10 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                rawResponse: modelResponse.rawResponse\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n};\n\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// core/embed/embed-many.ts\nasync function embedMany({\n  model,\n  values,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  var _a9;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a9 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a9 : false });\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationName: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings: embeddings2, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a10;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a10 = modelResponse.usage) != null ? _a10 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings3, usage: usage2 };\n            }\n          });\n        });\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({ values, embeddings: embeddings2, usage });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      let tokens = 0;\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => chunk.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a10;\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers\n              });\n              const embeddings2 = modelResponse.embeddings;\n              const usage2 = (_a10 = modelResponse.usage) != null ? _a10 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings2, usage: usage2 };\n            }\n          });\n        });\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens }\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n// core/prompt/convert-to-language-model-prompt.ts\n\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name2, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isDownloadError(error) {\n    return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      statusCode: this.statusCode,\n      statusText: this.statusText,\n      cause: this.cause\n    };\n  }\n};\n_a2 = symbol2;\n\n// util/download.ts\nasync function download({\n  url,\n  fetchImplementation = fetch\n}) {\n  var _a9;\n  const urlText = url.toString();\n  try {\n    const response = await fetchImplementation(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: (_a9 = response.headers.get(\"content-type\")) != null ? _a9 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name3, message, cause });\n    this[_a3] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidDataContentError(error) {\n    return error instanceof Error && error.name === name3 && error.content != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      content: this.content\n    };\n  }\n};\n_a3 = symbol3;\n\n// core/prompt/data-content.ts\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error(\"Error decoding Uint8Array to text\");\n  }\n}\n\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name4, message });\n    this[_a4] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidMessageRoleError(error) {\n    return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      role: this.role\n    };\n  }\n};\n_a4 = symbol4;\n\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  downloadImplementation = download\n}) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  const downloadedImages = modelSupportsImageUrls || prompt.messages == null ? null : await downloadImages(prompt.messages, downloadImplementation);\n  const promptType = prompt.type;\n  switch (promptType) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map(\n          (message) => convertToLanguageModelMessage(message, downloadedImages)\n        )\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = promptType;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message, downloadedImages) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return { role: \"system\", content: message.content };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }]\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map(\n          (part) => {\n            var _a9, _b, _c;\n            switch (part.type) {\n              case \"text\": {\n                return part;\n              }\n              case \"image\": {\n                if (part.image instanceof URL) {\n                  if (downloadedImages == null) {\n                    return {\n                      type: \"image\",\n                      image: part.image,\n                      mimeType: part.mimeType\n                    };\n                  } else {\n                    const downloadedImage = downloadedImages[part.image.toString()];\n                    return {\n                      type: \"image\",\n                      image: downloadedImage.data,\n                      mimeType: (_a9 = part.mimeType) != null ? _a9 : downloadedImage.mimeType\n                    };\n                  }\n                }\n                if (typeof part.image === \"string\") {\n                  try {\n                    const url = new URL(part.image);\n                    switch (url.protocol) {\n                      case \"http:\":\n                      case \"https:\": {\n                        if (downloadedImages == null) {\n                          return {\n                            type: \"image\",\n                            image: url,\n                            mimeType: part.mimeType\n                          };\n                        } else {\n                          const downloadedImage = downloadedImages[part.image];\n                          return {\n                            type: \"image\",\n                            image: downloadedImage.data,\n                            mimeType: (_b = part.mimeType) != null ? _b : downloadedImage.mimeType\n                          };\n                        }\n                      }\n                      case \"data:\": {\n                        try {\n                          const [header, base64Content] = part.image.split(\",\");\n                          const mimeType = header.split(\";\")[0].split(\":\")[1];\n                          if (mimeType == null || base64Content == null) {\n                            throw new Error(\"Invalid data URL format\");\n                          }\n                          return {\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content),\n                            mimeType\n                          };\n                        } catch (error) {\n                          throw new Error(\n                            `Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(\n                              message\n                            )}`\n                          );\n                        }\n                      }\n                      default: {\n                        throw new Error(\n                          `Unsupported URL protocol: ${url.protocol}`\n                        );\n                      }\n                    }\n                  } catch (_ignored) {\n                  }\n                }\n                const imageUint8 = convertDataContentToUint8Array(part.image);\n                return {\n                  type: \"image\",\n                  image: imageUint8,\n                  mimeType: (_c = part.mimeType) != null ? _c : detectImageMimeType(imageUint8)\n                };\n              }\n            }\n          }\n        )\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }]\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        )\n      };\n    }\n    case \"tool\": {\n      return message;\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadImages(messages, downloadImplementation) {\n  const urls = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter((part) => part.type === \"image\").map((part) => part.image).map(\n    (part) => (\n      // support string urls in image parts:\n      typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part\n    )\n  ).filter((image) => image instanceof URL);\n  const downloadedImages = await Promise.all(\n    urls.map(async (url) => ({\n      url,\n      data: await downloadImplementation({ url })\n    }))\n  );\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data])\n  );\n}\n\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.messages != null) {\n    for (const message of prompt.messages) {\n      if (message.role === \"system\" && typeof message.content !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n          prompt,\n          message: \"system message content must be a string\"\n        });\n      }\n    }\n  }\n  return prompt.prompt != null ? {\n    type: \"prompt\",\n    prompt: prompt.prompt,\n    messages: void 0,\n    system: prompt.system\n  } : {\n    type: \"messages\",\n    prompt: void 0,\n    messages: prompt.messages,\n    // only possible case bc of checks above\n    system: prompt.system\n  };\n}\n\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name5,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a5] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidArgumentError(error) {\n    return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      parameter: this.parameter,\n      value: this.value\n    };\n  }\n};\n_a5 = symbol5;\n\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/types/token-usage.ts\nfunction calculateCompletionTokenUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, {\n  contentType,\n  dataStreamVersion\n}) {\n  var _a9;\n  const headers = new Headers((_a9 = init == null ? void 0 : init.headers) != null ? _a9 : {});\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", contentType);\n  }\n  if (dataStreamVersion !== void 0) {\n    headers.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n  }\n  return headers;\n}\n\n// core/util/schema.ts\n\n\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\nfunction zodSchema(zodSchema2) {\n  return jsonSchema(\n    // we assume that zodToJsonSchema will return a valid JSONSchema7:\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(zodSchema2),\n    {\n      validate: (value) => {\n        const result = zodSchema2.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\n\n// core/generate-object/inject-json-schema-into-system.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nfunction injectJsonSchemaIntoSystem({\n  system,\n  schema,\n  schemaPrefix = DEFAULT_SCHEMA_PREFIX,\n  schemaSuffix = DEFAULT_SCHEMA_SUFFIX\n}) {\n  return [\n    system,\n    system != null ? \"\" : null,\n    // add a newline if system is not null\n    schemaPrefix,\n    JSON.stringify(schema),\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/no-object-generated-error.ts\n\nvar name6 = \"AI_NoObjectGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No object generated.\" } = {}) {\n    super({ name: name6, message });\n    this[_a6] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoObjectGeneratedError(error) {\n    return error instanceof Error && error.name === name6;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a6 = symbol6;\n\n// core/generate-object/generate-object.ts\nasync function generateObject({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  ...settings\n}) {\n  var _a9;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const schema = asSchema(inputSchema);\n  const tracer = getTracer({ isEnabled: (_a9 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a9 : false });\n  return recordSpan({\n    name: \"ai.generateObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationName: \"ai.generateObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": {\n          input: () => JSON.stringify(schema.jsonSchema)\n        },\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let result;\n      let finishReason;\n      let usage;\n      let warnings;\n      let rawResponse;\n      let logprobs;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = getValidatedPrompt({\n            system: model.supportsStructuredOutputs ? system : injectJsonSchemaIntoSystem({\n              system,\n              schema: schema.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationName: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-json\",\n                    schema: schema.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  abortSignal,\n                  headers\n                });\n                if (result2.text === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      \"ai.result.object\": { output: () => result2.text },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText: result2.text };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = getValidatedPrompt({\n            system,\n            prompt,\n            messages\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: validatedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls\n          });\n          const inputFormat = validatedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationName: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a10, _b;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-tool\",\n                    tool: {\n                      type: \"function\",\n                      name: schemaName != null ? schemaName : \"json\",\n                      description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                      parameters: schema.jsonSchema\n                    }\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  abortSignal,\n                  headers\n                });\n                const objectText = (_b = (_a10 = result2.toolCalls) == null ? void 0 : _a10[0]) == null ? void 0 : _b.args;\n                if (objectText === void 0) {\n                  throw new NoObjectGeneratedError();\n                }\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.finishReason\": result2.finishReason,\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      \"ai.result.object\": { output: () => objectText },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({ text: result, schema });\n      if (!parseResult.success) {\n        throw parseResult.error;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.finishReason\": finishReason,\n            \"ai.usage.promptTokens\": usage.promptTokens,\n            \"ai.usage.completionTokens\": usage.completionTokens,\n            \"ai.result.object\": {\n              output: () => JSON.stringify(parseResult.value)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateObjectResult({\n        object: parseResult.value,\n        finishReason,\n        usage: calculateCompletionTokenUsage(usage),\n        warnings,\n        rawResponse,\n        logprobs\n      });\n    }\n  });\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n  toJsonResponse(init) {\n    var _a9;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_generateObject = generateObject;\n\n// core/generate-object/stream-object.ts\n\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get value() {\n    if (this.promise) {\n      return this.promise;\n    }\n    this.promise = new Promise((resolve, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    return this.promise;\n  }\n  resolve(value) {\n    var _a9;\n    this.status = { type: \"resolved\", value };\n    if (this.promise) {\n      (_a9 = this._resolve) == null ? void 0 : _a9.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a9;\n    this.status = { type: \"rejected\", error };\n    if (this.promise) {\n      (_a9 = this._reject) == null ? void 0 : _a9.call(this, error);\n    }\n  }\n};\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/generate-object/stream-object.ts\nasync function streamObject({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  onFinish,\n  ...settings\n}) {\n  var _a9;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a9 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a9 : false });\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const schema = asSchema(inputSchema);\n  return recordSpan({\n    name: \"ai.streamObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationName: \"ai.streamObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": { input: () => JSON.stringify(schema.jsonSchema) },\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let callOptions;\n      let transformer;\n      switch (mode) {\n        case \"json\": {\n          const validatedPrompt = getValidatedPrompt({\n            system: model.supportsStructuredOutputs ? system : injectJsonSchemaIntoSystem({\n              system,\n              schema: schema.jsonSchema\n            }),\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-json\",\n              schema: schema.jsonSchema,\n              name: schemaName,\n              description: schemaDescription\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform: (chunk, controller) => {\n              switch (chunk.type) {\n                case \"text-delta\":\n                  controller.enqueue(chunk.textDelta);\n                  break;\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case \"tool\": {\n          const validatedPrompt = getValidatedPrompt({\n            system,\n            prompt,\n            messages\n          });\n          callOptions = {\n            mode: {\n              type: \"object-tool\",\n              tool: {\n                type: \"function\",\n                name: schemaName != null ? schemaName : \"json\",\n                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                parameters: schema.jsonSchema\n              }\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n              prompt: validatedPrompt,\n              modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            abortSignal,\n            headers\n          };\n          transformer = {\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"tool-call-delta\":\n                  controller.enqueue(chunk.argsTextDelta);\n                  break;\n                case \"finish\":\n                case \"error\":\n                  controller.enqueue(chunk);\n                  break;\n              }\n            }\n          };\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan\n      } = await retry(\n        () => recordSpan({\n          name: \"ai.streamObject.doStream\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationName: \"ai.streamObject.doStream\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.format\": {\n                input: () => callOptions.inputFormat\n              },\n              \"ai.prompt.messages\": {\n                input: () => JSON.stringify(callOptions.prompt)\n              },\n              \"ai.settings.mode\": mode,\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.max_tokens\": settings.maxTokens,\n              \"gen_ai.request.temperature\": settings.temperature,\n              \"gen_ai.request.top_p\": settings.topP\n            }\n          }),\n          tracer,\n          endWhenDone: false,\n          fn: async (doStreamSpan2) => ({\n            result: await model.doStream(callOptions),\n            doStreamSpan: doStreamSpan2\n          })\n        })\n      );\n      return new DefaultStreamObjectResult({\n        stream: stream.pipeThrough(new TransformStream(transformer)),\n        warnings,\n        rawResponse,\n        schema,\n        onFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry\n      });\n    }\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    schema,\n    onFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    this.objectPromise = new DelayedPromise();\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    let usage;\n    let finishReason;\n    let object;\n    let error;\n    let accumulatedText = \"\";\n    let delta = \"\";\n    let latestObject = void 0;\n    let firstChunk = true;\n    const self = this;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (firstChunk) {\n            firstChunk = false;\n            doStreamSpan.addEvent(\"ai.stream.firstChunk\");\n          }\n          if (typeof chunk === \"string\") {\n            accumulatedText += chunk;\n            delta += chunk;\n            const currentObject = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parsePartialJson)(\n              accumulatedText\n            );\n            if (!(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.isDeepEqualData)(latestObject, currentObject)) {\n              latestObject = currentObject;\n              controller.enqueue({\n                type: \"object\",\n                object: currentObject\n              });\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: delta\n              });\n              delta = \"\";\n            }\n            return;\n          }\n          switch (chunk.type) {\n            case \"finish\": {\n              if (delta !== \"\") {\n                controller.enqueue({\n                  type: \"text-delta\",\n                  textDelta: delta\n                });\n              }\n              finishReason = chunk.finishReason;\n              usage = calculateCompletionTokenUsage(chunk.usage);\n              controller.enqueue({ ...chunk, usage });\n              resolveUsage(usage);\n              const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                value: latestObject,\n                schema\n              });\n              if (validationResult.success) {\n                object = validationResult.value;\n                self.objectPromise.resolve(object);\n              } else {\n                error = validationResult.error;\n                self.objectPromise.reject(error);\n              }\n              break;\n            }\n            default: {\n              controller.enqueue(chunk);\n              break;\n            }\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          try {\n            const finalUsage = usage != null ? usage : {\n              promptTokens: NaN,\n              completionTokens: NaN,\n              totalTokens: NaN\n            };\n            doStreamSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.finishReason\": finishReason,\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.object\": {\n                    output: () => JSON.stringify(object)\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.usage.prompt_tokens\": finalUsage.promptTokens,\n                  \"gen_ai.usage.completion_tokens\": finalUsage.completionTokens,\n                  \"gen_ai.response.finish_reasons\": [finishReason]\n                }\n              })\n            );\n            doStreamSpan.end();\n            rootSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.object\": {\n                    output: () => JSON.stringify(object)\n                  }\n                }\n              })\n            );\n            await (onFinish == null ? void 0 : onFinish({\n              usage: finalUsage,\n              object,\n              error,\n              rawResponse,\n              warnings\n            }));\n          } catch (error2) {\n            controller.error(error2);\n          } finally {\n            rootSpan.end();\n          }\n        }\n      })\n    );\n  }\n  get object() {\n    return this.objectPromise.value;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"object\":\n            controller.enqueue(chunk.object);\n            break;\n          case \"text-delta\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"text-delta\":\n            controller.enqueue(chunk.textDelta);\n            break;\n          case \"object\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    var _a9;\n    response.writeHead((_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(new TextEncoderStream()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  toTextStreamResponse(init) {\n    var _a9;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamObject = streamObject;\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n  return object != null && Object.keys(object).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  return {\n    tools: Object.entries(tools).map(([name9, tool2]) => ({\n      type: \"function\",\n      name: name9,\n      description: tool2.description,\n      parameters: asSchema(tool2.parameters).jsonSchema\n    })),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/generate-text/tool-call.ts\n\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name7 = \"AI_InvalidToolArgumentsError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(\n      cause\n    )}`\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidToolArgumentsError(error) {\n    return error instanceof Error && error.name === name7 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      toolName: this.toolName,\n      toolArgs: this.toolArgs\n    };\n  }\n};\n_a7 = symbol7;\n\n// errors/no-such-tool-error.ts\n\nvar name8 = \"AI_NoSuchToolError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name8, message });\n    this[_a8] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchToolError(error) {\n    return error instanceof Error && error.name === name8 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      toolName: this.toolName,\n      availableTools: this.availableTools\n    };\n  }\n};\n_a8 = symbol8;\n\n// core/generate-text/tool-call.ts\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n    text: toolCall.args,\n    schema: asSchema(tool2.parameters)\n  });\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/generate-text.ts\nasync function generateText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxAutomaticRoundtrips = 0,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  experimental_telemetry: telemetry,\n  ...settings\n}) {\n  var _a9;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a9 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a9 : false });\n  return recordSpan({\n    name: \"ai.generateText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationName: \"ai.generateText\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.settings.maxToolRoundtrips\": maxToolRoundtrips\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a10, _b, _c, _d;\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      const mode = {\n        type: \"regular\",\n        ...prepareToolsAndToolChoice({ tools, toolChoice })\n      };\n      const callSettings = prepareCallSettings(settings);\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatedPrompt,\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      let currentModelResponse;\n      let currentToolCalls = [];\n      let currentToolResults = [];\n      let roundtripCount = 0;\n      const responseMessages = [];\n      const roundtrips = [];\n      const usage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0\n      };\n      do {\n        const currentInputFormat = roundtripCount === 0 ? validatedPrompt.type : \"messages\";\n        currentModelResponse = await retry(\n          () => recordSpan({\n            name: \"ai.generateText.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationName: \"ai.generateText.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.format\": { input: () => currentInputFormat },\n                \"ai.prompt.messages\": {\n                  input: () => JSON.stringify(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              const result = await model.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: currentInputFormat,\n                prompt: promptMessages,\n                abortSignal,\n                headers\n              });\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.finishReason\": result.finishReason,\n                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                    \"ai.result.text\": {\n                      output: () => result.text\n                    },\n                    \"ai.result.toolCalls\": {\n                      output: () => JSON.stringify(result.toolCalls)\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result.finishReason],\n                    \"gen_ai.usage.prompt_tokens\": result.usage.promptTokens,\n                    \"gen_ai.usage.completion_tokens\": result.usage.completionTokens\n                  }\n                })\n              );\n              return result;\n            }\n          })\n        );\n        currentToolCalls = ((_a10 = currentModelResponse.toolCalls) != null ? _a10 : []).map(\n          (modelToolCall) => parseToolCall({ toolCall: modelToolCall, tools })\n        );\n        currentToolResults = tools == null ? [] : await executeTools({\n          toolCalls: currentToolCalls,\n          tools,\n          tracer,\n          telemetry\n        });\n        const currentUsage = calculateCompletionTokenUsage(\n          currentModelResponse.usage\n        );\n        usage.completionTokens += currentUsage.completionTokens;\n        usage.promptTokens += currentUsage.promptTokens;\n        usage.totalTokens += currentUsage.totalTokens;\n        roundtrips.push({\n          text: (_b = currentModelResponse.text) != null ? _b : \"\",\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs\n        });\n        const newResponseMessages = toResponseMessages({\n          text: (_c = currentModelResponse.text) != null ? _c : \"\",\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults\n        });\n        responseMessages.push(...newResponseMessages);\n        promptMessages.push(\n          ...newResponseMessages.map(\n            (message) => convertToLanguageModelMessage(message, null)\n          )\n        );\n      } while (\n        // there are tool calls:\n        currentToolCalls.length > 0 && // all current tool calls have results:\n        currentToolResults.length === currentToolCalls.length && // the number of roundtrips is less than the maximum:\n        roundtripCount++ < maxToolRoundtrips\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.finishReason\": currentModelResponse.finishReason,\n            \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n            \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens,\n            \"ai.result.text\": {\n              output: () => currentModelResponse.text\n            },\n            \"ai.result.toolCalls\": {\n              output: () => JSON.stringify(currentModelResponse.toolCalls)\n            }\n          }\n        })\n      );\n      return new DefaultGenerateTextResult({\n        // Always return a string so that the caller doesn't have to check for undefined.\n        // If they need to check if the model did not return any text,\n        // they can check the length of the string:\n        text: (_d = currentModelResponse.text) != null ? _d : \"\",\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        rawResponse: currentModelResponse.rawResponse,\n        logprobs: currentModelResponse.logprobs,\n        responseMessages,\n        roundtrips\n      });\n    }\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationName: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolCall.toolName,\n            \"ai.toolCall.id\": toolCall.toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(toolCall.args)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          const result2 = await tool2.execute(toolCall.args);\n          try {\n            span.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.toolCall.result\": {\n                    output: () => JSON.stringify(result2)\n                  }\n                }\n              })\n            );\n          } catch (ignored) {\n          }\n          return result2;\n        }\n      });\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n    this.responseMessages = options.responseMessages;\n    this.roundtrips = options.roundtrips;\n  }\n};\nfunction toResponseMessages({\n  text,\n  toolCalls,\n  toolResults\n}) {\n  const responseMessages = [];\n  responseMessages.push({\n    role: \"assistant\",\n    content: [{ type: \"text\", text }, ...toolCalls]\n  });\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResults.map((result) => ({\n        type: \"tool-result\",\n        toolCallId: result.toolCallId,\n        toolName: result.toolName,\n        result: result.result\n      }))\n    });\n  }\n  return responseMessages;\n}\nvar experimental_generateText = generateText;\n\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n  let lastRead1 = void 0;\n  let lastRead2 = void 0;\n  let stream1Done = false;\n  let stream2Done = false;\n  async function readStream1(controller) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n      const result = await lastRead1;\n      lastRead1 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  async function readStream2(controller) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n      const result = await lastRead2;\n      lastRead2 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n        const { result, reader } = await Promise.race([\n          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),\n          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))\n        ]);\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n        if (reader === reader1) {\n          lastRead1 = void 0;\n          if (result.done) {\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = void 0;\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    }\n  });\n}\n\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const activeToolCalls = {};\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call-delta\": {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: \"tool-call-streaming-start\",\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              });\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n            controller.enqueue({\n              type: \"tool-call-delta\",\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta\n            });\n          }\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.generateId)();\n              outstandingToolCalls.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationName: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.args)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => tool2.execute(toolCall.args).then(\n                  (result) => {\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-result\",\n                      result\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                    try {\n                      span.setAttributes(\n                        selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.toolCall.result\": {\n                              output: () => JSON.stringify(result)\n                            }\n                          }\n                        })\n                      );\n                    } catch (ignored) {\n                    }\n                  },\n                  (error) => {\n                    toolResultsStreamController.enqueue({\n                      type: \"error\",\n                      error\n                    });\n                    outstandingToolCalls.delete(toolExecutionId);\n                    if (canClose && outstandingToolCalls.size === 0) {\n                      toolResultsStreamController.close();\n                    }\n                  }\n                )\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateCompletionTokenUsage(chunk.usage)\n          });\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nasync function streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_toolCallStreaming: toolCallStreaming = false,\n  onFinish,\n  ...settings\n}) {\n  var _a9;\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer({ isEnabled: (_a9 = telemetry == null ? void 0 : telemetry.isEnabled) != null ? _a9 : false });\n  return recordSpan({\n    name: \"ai.streamText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationName: \"ai.streamText\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        }\n      }\n    }),\n    tracer,\n    endWhenDone: false,\n    fn: async (rootSpan) => {\n      const retry = retryWithExponentialBackoff({ maxRetries });\n      const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: validatedPrompt,\n        modelSupportsImageUrls: model.supportsImageUrls\n      });\n      const {\n        result: { stream, warnings, rawResponse },\n        doStreamSpan\n      } = await retry(\n        () => recordSpan({\n          name: \"ai.streamText.doStream\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationName: \"ai.streamText.doStream\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.format\": {\n                input: () => validatedPrompt.type\n              },\n              \"ai.prompt.messages\": {\n                input: () => JSON.stringify(promptMessages)\n              },\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.max_tokens\": settings.maxTokens,\n              \"gen_ai.request.temperature\": settings.temperature,\n              \"gen_ai.request.top_p\": settings.topP\n            }\n          }),\n          tracer,\n          endWhenDone: false,\n          fn: async (doStreamSpan2) => {\n            return {\n              result: await model.doStream({\n                mode: {\n                  type: \"regular\",\n                  ...prepareToolsAndToolChoice({ tools, toolChoice })\n                },\n                ...prepareCallSettings(settings),\n                inputFormat: validatedPrompt.type,\n                prompt: promptMessages,\n                abortSignal,\n                headers\n              }),\n              doStreamSpan: doStreamSpan2\n            };\n          }\n        })\n      );\n      return new DefaultStreamTextResult({\n        stream: runToolsTransformation({\n          tools,\n          generatorStream: stream,\n          toolCallStreaming,\n          tracer,\n          telemetry\n        }),\n        warnings,\n        rawResponse,\n        onFinish,\n        rootSpan,\n        doStreamSpan,\n        telemetry\n      });\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    onFinish,\n    rootSpan,\n    doStreamSpan,\n    telemetry\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    this.onFinish = onFinish;\n    const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n    this.usage = usagePromise;\n    const { resolve: resolveFinishReason, promise: finishReasonPromise } = createResolvablePromise();\n    this.finishReason = finishReasonPromise;\n    const { resolve: resolveText, promise: textPromise } = createResolvablePromise();\n    this.text = textPromise;\n    const { resolve: resolveToolCalls, promise: toolCallsPromise } = createResolvablePromise();\n    this.toolCalls = toolCallsPromise;\n    const { resolve: resolveToolResults, promise: toolResultsPromise } = createResolvablePromise();\n    this.toolResults = toolResultsPromise;\n    let finishReason;\n    let usage;\n    let text = \"\";\n    const toolCalls = [];\n    const toolResults = [];\n    let firstChunk = true;\n    const self = this;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          controller.enqueue(chunk);\n          if (firstChunk) {\n            firstChunk = false;\n            doStreamSpan.addEvent(\"ai.stream.firstChunk\");\n          }\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case \"text-delta\":\n              text += chunk.textDelta;\n              break;\n            case \"tool-call\":\n              toolCalls.push(chunk);\n              break;\n            case \"tool-result\":\n              toolResults.push(chunk);\n              break;\n            case \"finish\":\n              usage = chunk.usage;\n              finishReason = chunk.finishReason;\n              resolveUsage(usage);\n              resolveFinishReason(finishReason);\n              resolveText(text);\n              resolveToolCalls(toolCalls);\n              break;\n            case \"tool-call-streaming-start\":\n            case \"tool-call-delta\":\n            case \"error\":\n              break;\n            default: {\n              const exhaustiveCheck = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          var _a9;\n          try {\n            const finalUsage = usage != null ? usage : {\n              promptTokens: NaN,\n              completionTokens: NaN,\n              totalTokens: NaN\n            };\n            const finalFinishReason = finishReason != null ? finishReason : \"unknown\";\n            const telemetryToolCalls = toolCalls.length > 0 ? JSON.stringify(toolCalls) : void 0;\n            doStreamSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.finishReason\": finalFinishReason,\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.text\": { output: () => text },\n                  \"ai.result.toolCalls\": { output: () => telemetryToolCalls },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.response.finish_reasons\": [finalFinishReason],\n                  \"gen_ai.usage.prompt_tokens\": finalUsage.promptTokens,\n                  \"gen_ai.usage.completion_tokens\": finalUsage.completionTokens\n                }\n              })\n            );\n            doStreamSpan.end();\n            rootSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.finishReason\": finalFinishReason,\n                  \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                  \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                  \"ai.result.text\": { output: () => text },\n                  \"ai.result.toolCalls\": { output: () => telemetryToolCalls }\n                }\n              })\n            );\n            resolveToolResults(toolResults);\n            await ((_a9 = self.onFinish) == null ? void 0 : _a9.call(self, {\n              finishReason: finalFinishReason,\n              usage: finalUsage,\n              text,\n              toolCalls,\n              // The tool results are inferred as a never[] type, because they are\n              // optional and the execute method with an inferred result type is\n              // optional as well. Therefore we need to cast the toolResults to any.\n              // The type exposed to the users will be correctly inferred.\n              toolResults,\n              rawResponse,\n              warnings\n            }));\n          } catch (error) {\n            controller.error(error);\n          } finally {\n            rootSpan.end();\n          }\n        }\n      })\n    );\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.originalStream.tee();\n    this.originalStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk.textDelta);\n          }\n        } else if (chunk.type === \"error\") {\n          controller.error(chunk.error);\n        }\n      }\n    });\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk);\n          }\n        } else {\n          controller.enqueue(chunk);\n        }\n      }\n    });\n  }\n  toAIStream(callbacks = {}) {\n    return this.toDataStream({ callbacks });\n  }\n  toDataStream({\n    callbacks = {},\n    getErrorMessage: getErrorMessage4 = () => \"\"\n    // mask error messages for safety by default\n  } = {}) {\n    let aggregatedResponse = \"\";\n    const callbackTransformer = new TransformStream({\n      async start() {\n        if (callbacks.onStart)\n          await callbacks.onStart();\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"text-delta\") {\n          const textDelta = chunk.textDelta;\n          aggregatedResponse += textDelta;\n          if (callbacks.onToken)\n            await callbacks.onToken(textDelta);\n          if (callbacks.onText)\n            await callbacks.onText(textDelta);\n        }\n      },\n      async flush() {\n        if (callbacks.onCompletion)\n          await callbacks.onCompletion(aggregatedResponse);\n        if (callbacks.onFinal)\n          await callbacks.onFinal(aggregatedResponse);\n      }\n    });\n    const streamPartsTransformer = new TransformStream({\n      transform: async (chunk, controller) => {\n        const chunkType = chunk.type;\n        switch (chunkType) {\n          case \"text-delta\":\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", chunk.textDelta));\n            break;\n          case \"tool-call-streaming-start\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_streaming_start\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              })\n            );\n            break;\n          case \"tool-call-delta\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_delta\", {\n                toolCallId: chunk.toolCallId,\n                argsTextDelta: chunk.argsTextDelta\n              })\n            );\n            break;\n          case \"tool-call\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args\n              })\n            );\n            break;\n          case \"tool-result\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_result\", {\n                toolCallId: chunk.toolCallId,\n                result: chunk.result\n              })\n            );\n            break;\n          case \"error\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", getErrorMessage4(chunk.error))\n            );\n            break;\n          case \"finish\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"finish_message\", {\n                finishReason: chunk.finishReason,\n                usage: {\n                  promptTokens: chunk.usage.promptTokens,\n                  completionTokens: chunk.usage.completionTokens\n                }\n              })\n            );\n            break;\n          default: {\n            const exhaustiveCheck = chunkType;\n            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n    return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer).pipeThrough(new TextEncoderStream());\n  }\n  pipeAIStreamToResponse(response, init) {\n    return this.pipeDataStreamToResponse(response, init);\n  }\n  pipeDataStreamToResponse(response, init) {\n    var _a9;\n    response.writeHead((_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.toDataStream().getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  pipeTextStreamToResponse(response, init) {\n    var _a9;\n    response.writeHead((_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(new TextEncoderStream()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  toAIStreamResponse(options) {\n    return this.toDataStreamResponse(options);\n  }\n  toDataStreamResponse(options) {\n    var _a9;\n    const init = options == null ? void 0 : \"init\" in options ? options.init : {\n      headers: \"headers\" in options ? options.headers : void 0,\n      status: \"status\" in options ? options.status : void 0,\n      statusText: \"statusText\" in options ? options.statusText : void 0\n    };\n    const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n    const getErrorMessage4 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n    const stream = data ? mergeStreams(data.stream, this.toDataStream({ getErrorMessage: getErrorMessage4 })) : this.toDataStream({ getErrorMessage: getErrorMessage4 });\n    return new Response(stream, {\n      status: (_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\",\n        dataStreamVersion: \"v1\"\n      })\n    });\n  }\n  toTextStreamResponse(init) {\n    var _a9;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamText = streamText;\n\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n  var _a9, _b, _c;\n  const parts = [];\n  for (const attachment of attachments) {\n    let url;\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n    switch (url.protocol) {\n      case \"http:\":\n      case \"https:\": {\n        if ((_a9 = attachment.contentType) == null ? void 0 : _a9.startsWith(\"image/\")) {\n          parts.push({ type: \"image\", image: url });\n        }\n        break;\n      }\n      case \"data:\": {\n        let header;\n        let base64Content;\n        let mimeType;\n        try {\n          [header, base64Content] = attachment.url.split(\",\");\n          mimeType = header.split(\";\")[0].split(\":\")[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n        if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n          parts.push({\n            type: \"image\",\n            image: convertDataContentToUint8Array(base64Content)\n          });\n        } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n          parts.push({\n            type: \"text\",\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content)\n            )\n          });\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n  return parts;\n}\n\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages) {\n  const coreMessages = [];\n  for (const {\n    role,\n    content,\n    toolInvocations,\n    experimental_attachments\n  } of messages) {\n    switch (role) {\n      case \"system\": {\n        coreMessages.push({\n          role: \"system\",\n          content\n        });\n        break;\n      }\n      case \"user\": {\n        coreMessages.push({\n          role: \"user\",\n          content: experimental_attachments ? [\n            { type: \"text\", text: content },\n            ...attachmentsToParts(experimental_attachments)\n          ] : content\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (toolInvocations == null) {\n          coreMessages.push({ role: \"assistant\", content });\n          break;\n        }\n        coreMessages.push({\n          role: \"assistant\",\n          content: [\n            { type: \"text\", text: content },\n            ...toolInvocations.map(({ toolCallId, toolName, args }) => ({\n              type: \"tool-call\",\n              toolCallId,\n              toolName,\n              args\n            }))\n          ]\n        });\n        coreMessages.push({\n          role: \"tool\",\n          content: toolInvocations.map(\n            ({ toolCallId, toolName, args, result }) => ({\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              args,\n              result\n            })\n          )\n        });\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unhandled role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return coreMessages;\n}\n\n// core/registry/invalid-model-id-error.ts\nvar InvalidModelIdError = class extends Error {\n  constructor({\n    id,\n    message = `Invalid model id: ${id}`\n  }) {\n    super(message);\n    this.name = \"AI_InvalidModelIdError\";\n    this.id = id;\n  }\n  static isInvalidModelIdError(error) {\n    return error instanceof Error && error.name === \"AI_InvalidModelIdError\" && typeof error.id === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      id: this.id\n    };\n  }\n};\n\n// core/registry/no-such-model-error.ts\nvar NoSuchModelError = class extends Error {\n  constructor({\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super(message);\n    this.name = \"AI_NoSuchModelError\";\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isNoSuchModelError(error) {\n    return error instanceof Error && error.name === \"AI_NoSuchModelError\" && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType\n    };\n  }\n};\n\n// core/registry/no-such-provider-error.ts\nvar NoSuchProviderError = class extends Error {\n  constructor({\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super(message);\n    this.name = \"AI_NoSuchProviderError\";\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isNoSuchProviderError(error) {\n    return error instanceof Error && error.name === \"AI_NoSuchProviderError\" && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      providerId: this.providerId,\n      availableProviders: this.availableProviders\n    };\n  }\n};\n\n// core/registry/provider-registry.ts\nfunction experimental_createProviderRegistry(providers) {\n  const registry = new DefaultProviderRegistry();\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor() {\n    this.providers = {};\n  }\n  registerProvider({ id, provider }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id) {\n    const index = id.indexOf(\":\");\n    if (index === -1) {\n      throw new InvalidModelIdError({ id });\n    }\n    return [id.slice(0, index), id.slice(index + 1)];\n  }\n  languageModel(id) {\n    var _a9, _b;\n    const [providerId, modelId] = this.splitId(id);\n    const model = (_b = (_a9 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a9, modelId);\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: \"language model\" });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a9, _b;\n    const [providerId, modelId] = this.splitId(id);\n    const model = (_b = (_a9 = this.getProvider(providerId)).textEmbedding) == null ? void 0 : _b.call(_a9, modelId);\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: \"text embedding model\"\n      });\n    }\n    return model;\n  }\n};\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\n      `Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`\n    );\n  }\n  return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n  return vector1.reduce(\n    (accumulator, value, index) => accumulator + value * vector2[index],\n    0\n  );\n}\nfunction magnitude(vector) {\n  return Math.sqrt(dotProduct(vector, vector));\n}\n\n// errors/index.ts\n\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_5__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a9;\n      await ((_a9 = it.return) == null ? void 0 : _a9.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\n\nvar STREAM_DATA_WARNING_TIME_MS = 15 * 1e3;\nvar StreamData2 = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    this.isClosed = false;\n    this.warningTimeout = null;\n    const self = this;\n    this.stream = new ReadableStream({\n      start: async (controller) => {\n        self.controller = controller;\n        if (true) {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n            );\n          }, STREAM_DATA_WARNING_TIME_MS);\n        }\n      },\n      pull: (controller) => {\n      },\n      cancel: (reason) => {\n        this.isClosed = true;\n      }\n    });\n  }\n  async close() {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.close();\n    this.isClosed = true;\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data\", [value]))\n    );\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"message_annotations\", [value]))\n    );\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData2 {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a9;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a10, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a10 = value.data.delta.content) == null ? void 0 : _a10[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a9 = error.message) != null ? _a9 : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a9, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a9 = response.body) != null ? _a9 : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a9;\n    return (_a9 = chunk.delta) == null ? void 0 : _a9.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a9;\n  const reader = (_a9 = res.body) == null ? void 0 : _a9.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a9, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a9 = chunk.candidates) == null ? void 0 : _a9[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a9, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a9 = value.token) == null ? void 0 : _a9.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a9, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a9 = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a9.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a9;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a9 = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a9.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n  toAIStream: () => toAIStream,\n  toDataStream: () => toDataStream,\n  toDataStreamResponse: () => toDataStreamResponse\n});\nfunction toAIStream(stream, callbacks) {\n  return toDataStream(stream, callbacks);\n}\nfunction toDataStream(stream, callbacks) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform: async (value, controller) => {\n        var _a9;\n        if (typeof value === \"string\") {\n          controller.enqueue(value);\n          return;\n        }\n        if (\"event\" in value) {\n          if (value.event === \"on_chat_model_stream\") {\n            forwardAIMessageChunk(\n              (_a9 = value.data) == null ? void 0 : _a9.chunk,\n              controller\n            );\n          }\n          return;\n        }\n        forwardAIMessageChunk(value, controller);\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse(stream, options) {\n  var _a9;\n  const dataStream = toDataStream(stream, options == null ? void 0 : options.callbacks);\n  const data = options == null ? void 0 : options.data;\n  const init = options == null ? void 0 : options.init;\n  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n  return new Response(responseStream, {\n    status: (_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200,\n    statusText: init == null ? void 0 : init.statusText,\n    headers: prepareResponseHeaders(init, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    })\n  });\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n  if (typeof chunk.content === \"string\") {\n    controller.enqueue(chunk.content);\n  } else {\n    const content = chunk.content;\n    for (const item of content) {\n      if (item.type === \"text\") {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a9, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a9 = chunk.choices[0]) == null ? void 0 : _a9.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a9, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a9 = choice.delta) == null ? void 0 : _a9.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a9, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a9 = json.choices[0]) == null ? void 0 : _a9.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.createChunkDecoder)();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a9;\n  const url = (_a9 = res.urls) == null ? void 0 : _a9.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n  var _a9;\n  response.writeHead((_a9 = init == null ? void 0 : init.status) != null ? _a9 : 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  let processedStream = res;\n  if (data) {\n    processedStream = mergeStreams(data.stream, res);\n  }\n  const reader = processedStream.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = mergeStreams(data.stream, res);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFOztBQUVBO0FBTTBCO0FBQzRDOztBQUV0RTtBQUNnRDtBQUN1Qjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0EsK0JBQStCLHdEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxvRUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVFQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsd0JBQXdCLGFBQWE7QUFDakY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtDQUFrQywwREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFVLGlFQUFpRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLHNDQUFzQyxhQUFhO0FBQzdG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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUEwQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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akM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxpQ0FBaUMsa0VBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw4REFBYztBQUNoQyxhQUFhLDhEQUFjO0FBMEV6QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNrX2RvYy8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz8xNWRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZTkgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWU5LCB7IGdldDogYWxsW25hbWU5XSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHN0cmVhbXMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIHBhcnNlU3RyZWFtUGFydCxcbiAgcmVhZERhdGFTdHJlYW0sXG4gIHBhcnNlQ29tcGxleFJlc3BvbnNlXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRJbXBsIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHV0aWwvZGVsYXkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG5cbi8vIHV0aWwvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUgPSBcIkFJX1JldHJ5RXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgcmVhc29uLFxuICAgIGVycm9yc1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzUmV0cnlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUgJiYgdHlwZW9mIGVycm9yLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KGVycm9yLmVycm9ycyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICByZWFzb246IHRoaXMucmVhc29uLFxuICAgICAgbGFzdEVycm9yOiB0aGlzLmxhc3RFcnJvcixcbiAgICAgIGVycm9yczogdGhpcy5lcnJvcnNcbiAgICB9O1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG5cbi8vIHV0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvYXNzZW1ibGUtb3BlcmF0aW9uLW5hbWUudHNcbmZ1bmN0aW9uIGFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gIG9wZXJhdGlvbk5hbWUsXG4gIHRlbGVtZXRyeVxufSkge1xuICByZXR1cm4ge1xuICAgIFwib3BlcmF0aW9uLm5hbWVcIjogYCR7b3BlcmF0aW9uTmFtZX0keyh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkKSAhPSBudWxsID8gYCAke3RlbGVtZXRyeS5mdW5jdGlvbklkfWAgOiBcIlwifWBcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hOTtcbiAgcmV0dXJuIHtcbiAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBzZXR0aW5nczpcbiAgICAuLi5PYmplY3QuZW50cmllcyhzZXR0aW5ncykucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSksXG4gICAgLy8gc3BlY2lhbCB0ZWxlbWV0cnkgaW5mb3JtYXRpb25cbiAgICBcInJlc291cmNlLm5hbWVcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCxcbiAgICBcImFpLnRlbGVtZXRyeS5mdW5jdGlvbklkXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gYWRkIG1ldGFkYXRhIGFzIGF0dHJpYnV0ZXM6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoKF9hOSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5Lm1ldGFkYXRhKSAhPSBudWxsID8gX2E5IDoge30pLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkudGVsZW1ldHJ5Lm1ldGFkYXRhLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyByZXF1ZXN0IGhlYWRlcnNcbiAgICAuLi5PYmplY3QuZW50cmllcyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5yZXF1ZXN0LmhlYWRlcnMuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcblxuLy8gY29yZS90ZWxlbWV0cnkvbm9vcC10cmFjZXIudHNcbnZhciBub29wVHJhY2VyID0ge1xuICBzdGFydFNwYW4oKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuO1xuICB9LFxuICBzdGFydEFjdGl2ZVNwYW4obmFtZTksIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xudmFyIHRlc3RUcmFjZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBnZXRUcmFjZXIoeyBpc0VuYWJsZWQgfSkge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybiBub29wVHJhY2VyO1xuICB9XG4gIGlmICh0ZXN0VHJhY2VyKSB7XG4gICAgcmV0dXJuIHRlc3RUcmFjZXI7XG4gIH1cbiAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcihcImFpXCIpO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTksXG4gIHRyYWNlcixcbiAgYXR0cmlidXRlcyxcbiAgZm4sXG4gIGVuZFdoZW5Eb25lID0gdHJ1ZVxufSkge1xuICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihuYW1lOSwgeyBhdHRyaWJ1dGVzIH0sIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKHNwYW4pO1xuICAgICAgaWYgKGVuZFdoZW5Eb25lKSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L3NlbGVjdC10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIHRlbGVtZXRyeSxcbiAgYXR0cmlidXRlc1xufSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykucmVkdWNlKChhdHRyaWJ1dGVzMiwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImlucHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlucHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkSW5wdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuaW5wdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm91dHB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZE91dHB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5vdXRwdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHZhbHVlIH07XG4gIH0sIHt9KTtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWQoe1xuICBtb2RlbCxcbiAgdmFsdWUsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTkgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9IG51bGwgPyBfYTkgOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uTmFtZTogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZW1iZWQuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHsgaW5wdXQ6ICgpID0+IFtKU09OLnN0cmluZ2lmeSh2YWx1ZSldIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTEwO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbdmFsdWVdLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZzIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3NbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTEwID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTAgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3MubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVtYmVkZGluZzMpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZzMpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmc6IGVtYmVkZGluZzIsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHVzYWdlMixcbiAgICAgICAgICAgICAgICByYXdSZXNwb25zZTogbW9kZWxSZXNwb25zZS5yYXdSZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ1wiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkUmVzdWx0KHsgdmFsdWUsIGVtYmVkZGluZywgdXNhZ2UsIHJhd1Jlc3BvbnNlIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdGhpcy5lbWJlZGRpbmcgPSBvcHRpb25zLmVtYmVkZGluZztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gb3B0aW9ucy5yYXdSZXNwb25zZTtcbiAgfVxufTtcblxuLy8gY29yZS91dGlsL3NwbGl0LWFycmF5LnRzXG5mdW5jdGlvbiBzcGxpdEFycmF5KGFycmF5LCBjaHVua1NpemUpIHtcbiAgaWYgKGNodW5rU2l6ZSA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xuICAgIHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGksIGkgKyBjaHVua1NpemUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBjb3JlL2VtYmVkL2VtYmVkLW1hbnkudHNcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkTWFueSh7XG4gIG1vZGVsLFxuICB2YWx1ZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoeyBpc0VuYWJsZWQ6IChfYTkgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9IG51bGwgPyBfYTkgOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbk5hbWU6IFwiYWkuZW1iZWRNYW55XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgbWF4RW1iZWRkaW5nc1BlckNhbGwgPSBtb2RlbC5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICAgIGlmIChtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTA7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTEwID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTAgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MzLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHsgdmFsdWVzLCBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBsZXQgdG9rZW5zID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdmFsdWVDaHVua3MpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiByZXNwb25zZUVtYmVkZGluZ3MsIHVzYWdlIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMDtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogY2h1bmssXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTEwID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTAgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbWJlZGRpbmdzLnB1c2goLi4ucmVzcG9uc2VFbWJlZGRpbmdzKTtcbiAgICAgICAgdG9rZW5zICs9IHVzYWdlLnRva2VucztcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB0b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRNYW55UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBvcHRpb25zLmVtYmVkZGluZ3M7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHV0aWwvZG93bmxvYWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBEb3dubG9hZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0Rvd25sb2FkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMiAmJiB0eXBlb2YgZXJyb3IudXJsID09PSBcInN0cmluZ1wiICYmIChlcnJvci5zdGF0dXNDb2RlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c0NvZGUgPT09IFwibnVtYmVyXCIpICYmIChlcnJvci5zdGF0dXNUZXh0ID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlXG4gICAgfTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHV0aWwvZG93bmxvYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHtcbiAgdXJsLFxuICBmZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2hcbn0pIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsZW1lbnRhdGlvbih1cmxUZXh0KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWltZVR5cGU6IChfYTkgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgIT0gbnVsbCA/IF9hOSA6IHZvaWQgMFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7IHVybDogdXJsVGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHNcbnZhciBtaW1lVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvZ2lmXCIsIGJ5dGVzOiBbNzEsIDczLCA3MF0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIiwgYnl0ZXM6IFsxMzcsIDgwLCA3OCwgNzFdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvanBlZ1wiLCBieXRlczogWzI1NSwgMjE2XSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3dlYnBcIiwgYnl0ZXM6IFs4MiwgNzMsIDcwLCA3MF0gfVxuXTtcbmZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2UpIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKSkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgSW52YWxpZERhdGFDb250ZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWREYXRhQ29udGVudEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTMgJiYgZXJyb3IuY29udGVudCAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgIH07XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KG5ldyBVaW50OEFycmF5KGNvbnRlbnQpKTtcbiAgfVxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KHVpbnQ4QXJyYXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGRlY29kaW5nIFVpbnQ4QXJyYXkgdG8gdGV4dFwiKTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMucm9sZSA9IHJvbGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU0ICYmIHR5cGVvZiBlcnJvci5yb2xlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICByb2xlOiB0aGlzLnJvbGVcbiAgICB9O1xuICB9XG59O1xuX2E0ID0gc3ltYm9sNDtcblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPSB0cnVlLFxuICBkb3dubG9hZEltcGxlbWVudGF0aW9uID0gZG93bmxvYWRcbn0pIHtcbiAgY29uc3QgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzID0gW107XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgfHwgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwgPyBudWxsIDogYXdhaXQgZG93bmxvYWRJbWFnZXMocHJvbXB0Lm1lc3NhZ2VzLCBkb3dubG9hZEltcGxlbWVudGF0aW9uKTtcbiAgY29uc3QgcHJvbXB0VHlwZSA9IHByb21wdC50eXBlO1xuICBzd2l0Y2ggKHByb21wdFR5cGUpIHtcbiAgICBjYXNlIFwicHJvbXB0XCI6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBwcm9tcHQucHJvbXB0IH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibWVzc2FnZXNcIjoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoXG4gICAgICAgICAgKG1lc3NhZ2UpID0+IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRJbWFnZXMpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHByb21wdFR5cGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByb21wdCB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkSW1hZ2VzKSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgcmV0dXJuIHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogbWVzc2FnZS5jb250ZW50IH07XG4gICAgfVxuICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgICAgKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTksIF9iLCBfYztcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRlZEltYWdlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBwYXJ0LmltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZGVkSW1hZ2UgPSBkb3dubG9hZGVkSW1hZ2VzW3BhcnQuaW1hZ2UudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBkb3dubG9hZGVkSW1hZ2UuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9hOSA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYTkgOiBkb3dubG9hZGVkSW1hZ2UubWltZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LmltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhcnQuaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkZWRJbWFnZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZGVkSW1hZ2UgPSBkb3dubG9hZGVkSW1hZ2VzW3BhcnQuaW1hZ2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogZG93bmxvYWRlZEltYWdlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IChfYiA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYiA6IGRvd25sb2FkZWRJbWFnZS5taW1lVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBwYXJ0LmltYWdlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIFVSTCBmb3JtYXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2dldEVycm9yTWVzc2FnZTIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYFVuc3VwcG9ydGVkIFVSTCBwcm90b2NvbDogJHt1cmwucHJvdG9jb2x9YFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9pZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkocGFydC5pbWFnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVpbnQ4LFxuICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IChfYyA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYyA6IGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2VVaW50OClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIlxuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoeyByb2xlOiBfZXhoYXVzdGl2ZUNoZWNrIH0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRJbWFnZXMobWVzc2FnZXMsIGRvd25sb2FkSW1wbGVtZW50YXRpb24pIHtcbiAgY29uc3QgdXJscyA9IG1lc3NhZ2VzLmZpbHRlcigobWVzc2FnZSkgPT4gbWVzc2FnZS5yb2xlID09PSBcInVzZXJcIikubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLmNvbnRlbnQpLmZpbHRlcihcbiAgICAoY29udGVudCkgPT4gQXJyYXkuaXNBcnJheShjb250ZW50KVxuICApLmZsYXQoKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiKS5tYXAoKHBhcnQpID0+IHBhcnQuaW1hZ2UpLm1hcChcbiAgICAocGFydCkgPT4gKFxuICAgICAgLy8gc3VwcG9ydCBzdHJpbmcgdXJscyBpbiBpbWFnZSBwYXJ0czpcbiAgICAgIHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiICYmIChwYXJ0LnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fCBwYXJ0LnN0YXJ0c1dpdGgoXCJodHRwczpcIikpID8gbmV3IFVSTChwYXJ0KSA6IHBhcnRcbiAgICApXG4gICkuZmlsdGVyKChpbWFnZSkgPT4gaW1hZ2UgaW5zdGFuY2VvZiBVUkwpO1xuICBjb25zdCBkb3dubG9hZGVkSW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdXJscy5tYXAoYXN5bmMgKHVybCkgPT4gKHtcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IGF3YWl0IGRvd25sb2FkSW1wbGVtZW50YXRpb24oeyB1cmwgfSlcbiAgICB9KSlcbiAgKTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb3dubG9hZGVkSW1hZ2VzLm1hcCgoeyB1cmwsIGRhdGEgfSkgPT4gW3VybC50b1N0cmluZygpLCBkYXRhXSlcbiAgKTtcbn1cblxuLy8gY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZWRQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwcm9tcHQubWVzc2FnZXMpIHtcbiAgICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwic3lzdGVtXCIgJiYgdHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbWVzc2FnZTogXCJzeXN0ZW0gbWVzc2FnZSBjb250ZW50IG11c3QgYmUgYSBzdHJpbmdcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb21wdC5wcm9tcHQgIT0gbnVsbCA/IHtcbiAgICB0eXBlOiBcInByb21wdFwiLFxuICAgIHByb21wdDogcHJvbXB0LnByb21wdCxcbiAgICBtZXNzYWdlczogdm9pZCAwLFxuICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICB9IDoge1xuICAgIHR5cGU6IFwibWVzc2FnZXNcIixcbiAgICBwcm9tcHQ6IHZvaWQgMCxcbiAgICBtZXNzYWdlczogcHJvbXB0Lm1lc3NhZ2VzLFxuICAgIC8vIG9ubHkgcG9zc2libGUgY2FzZSBiYyBvZiBjaGVja3MgYWJvdmVcbiAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgfTtcbn1cblxuLy8gZXJyb3JzL2ludmFsaWQtYXJndW1lbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU1ID0gXCJBSV9JbnZhbGlkQXJndW1lbnRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZEFyZ3VtZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I1IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcmFtZXRlcixcbiAgICB2YWx1ZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNSxcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFyZ3VtZW50IGZvciBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJ9OiAke21lc3NhZ2V9YFxuICAgIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I1Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZEFyZ3VtZW50RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNSAmJiB0eXBlb2YgZXJyb3IucGFyYW1ldGVyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci52YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcGFyYW1ldGVyOiB0aGlzLnBhcmFtZXRlcixcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50c1xuZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc3RvcFNlcXVlbmNlcyxcbiAgc2VlZCxcbiAgbWF4UmV0cmllc1xufSkge1xuICBpZiAobWF4VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgPj0gMVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBcInRlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BQXCIsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiBcInRvcFAgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImZyZXF1ZW5jeVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwiZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2VlZFwiLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogXCJzZWVkIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSAhPSBudWxsID8gdGVtcGVyYXR1cmUgOiAwLFxuICAgIHRvcFAsXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczogc3RvcFNlcXVlbmNlcyAhPSBudWxsICYmIHN0b3BTZXF1ZW5jZXMubGVuZ3RoID4gMCA/IHN0b3BTZXF1ZW5jZXMgOiB2b2lkIDAsXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMlxuICB9O1xufVxuXG4vLyBjb3JlL3R5cGVzL3Rva2VuLXVzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZSh1c2FnZSkge1xuICByZXR1cm4ge1xuICAgIHByb21wdFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgIGNvbXBsZXRpb25Ub2tlbnM6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgdG90YWxUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyArIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL3ByZXBhcmUtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gIGNvbnRlbnRUeXBlLFxuICBkYXRhU3RyZWFtVmVyc2lvblxufSkge1xuICB2YXIgX2E5O1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKF9hOSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgIT0gbnVsbCA/IF9hOSA6IHt9KTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgfVxuICBpZiAoZGF0YVN0cmVhbVZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnMuc2V0KFwiWC1WZXJjZWwtQUktRGF0YS1TdHJlYW1cIiwgZGF0YVN0cmVhbVZlcnNpb24pO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBjb3JlL3V0aWwvc2NoZW1hLnRzXG5pbXBvcnQgeyB2YWxpZGF0b3JTeW1ib2wgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG52YXIgc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS5zY2hlbWFcIik7XG5mdW5jdGlvbiBqc29uU2NoZW1hKGpzb25TY2hlbWEyLCB7XG4gIHZhbGlkYXRlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBbc2NoZW1hU3ltYm9sXTogdHJ1ZSxcbiAgICBfdHlwZTogdm9pZCAwLFxuICAgIC8vIHNob3VsZCBuZXZlciBiZSB1c2VkIGRpcmVjdGx5XG4gICAgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsXG4gICAganNvblNjaGVtYToganNvblNjaGVtYTIsXG4gICAgdmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgc2NoZW1hU3ltYm9sIGluIHZhbHVlICYmIHZhbHVlW3NjaGVtYVN5bWJvbF0gPT09IHRydWUgJiYgXCJqc29uU2NoZW1hXCIgaW4gdmFsdWUgJiYgXCJ2YWxpZGF0ZVwiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gYXNTY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiBpc1NjaGVtYShzY2hlbWEpID8gc2NoZW1hIDogem9kU2NoZW1hKHNjaGVtYSk7XG59XG5mdW5jdGlvbiB6b2RTY2hlbWEoem9kU2NoZW1hMikge1xuICByZXR1cm4ganNvblNjaGVtYShcbiAgICAvLyB3ZSBhc3N1bWUgdGhhdCB6b2RUb0pzb25TY2hlbWEgd2lsbCByZXR1cm4gYSB2YWxpZCBKU09OU2NoZW1hNzpcbiAgICB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hMiksXG4gICAge1xuICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB6b2RTY2hlbWEyLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9pbmplY3QtanNvbi1zY2hlbWEtaW50by1zeXN0ZW0udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xuZnVuY3Rpb24gaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oe1xuICBzeXN0ZW0sXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gREVGQVVMVF9TQ0hFTUFfUFJFRklYLFxuICBzY2hlbWFTdWZmaXggPSBERUZBVUxUX1NDSEVNQV9TVUZGSVhcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICBzeXN0ZW0sXG4gICAgc3lzdGVtICE9IG51bGwgPyBcIlwiIDogbnVsbCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHN5c3RlbSBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBKU09OLnN0cmluZ2lmeShzY2hlbWEpLFxuICAgIHNjaGVtYVN1ZmZpeFxuICBdLmZpbHRlcigobGluZSkgPT4gbGluZSAhPSBudWxsKS5qb2luKFwiXFxuXCIpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9uby1vYmplY3QtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNiA9IFwiQUlfTm9PYmplY3RHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjYge1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJObyBvYmplY3QgZ2VuZXJhdGVkLlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTYsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzTm9PYmplY3RHZW5lcmF0ZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU2O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH07XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHtcbiAgbW9kZWwsXG4gIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBtb2RlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhciBfYTk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHNjaGVtYSA9IGFzU2NoZW1hKGlucHV0U2NoZW1hKTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2E5ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2E5IDogZmFsc2UgfSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uTmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNjaGVtYVwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHNjaGVtYS5qc29uU2NoZW1hKVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgIFwiYWkuc2NoZW1hLmRlc2NyaXB0aW9uXCI6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgbGV0IHVzYWdlO1xuICAgICAgbGV0IHdhcm5pbmdzO1xuICAgICAgbGV0IHJhd1Jlc3BvbnNlO1xuICAgICAgbGV0IGxvZ3Byb2JzO1xuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gc3lzdGVtIDogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oe1xuICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWFcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gdmFsaWRhdGVkUHJvbXB0LnR5cGU7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC1qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQsXG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIudGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiByZXN1bHQyLnRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dDogcmVzdWx0Mi50ZXh0IH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC5vYmplY3RUZXh0O1xuICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB2YWxpZGF0ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gdmFsaWRhdGVkUHJvbXB0LnR5cGU7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTAsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUgIT0gbnVsbCA/IHNjaGVtYU5hbWUgOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCA/IHNjaGVtYURlc2NyaXB0aW9uIDogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBzY2hlbWEuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RUZXh0ID0gKF9iID0gKF9hMTAgPSByZXN1bHQyLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTBbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5hcmdzO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RUZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IG9iamVjdFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiByZXN1bHQsIHNjaGVtYSB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBwYXJzZVJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwYXJzZVJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICBvYmplY3Q6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlOiBjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZSh1c2FnZSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgbG9ncHJvYnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vYmplY3QgPSBvcHRpb25zLm9iamVjdDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICB9XG4gIHRvSnNvblJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2E5O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTkgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hOSA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0ID0gZ2VuZXJhdGVPYmplY3Q7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7XG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAgcGFyc2VQYXJ0aWFsSnNvblxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIHV0aWwvZGVsYXllZC1wcm9taXNlLnRzXG52YXIgRGVsYXllZFByb21pc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInBlbmRpbmdcIiB9O1xuICAgIHRoaXMuX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVqZWN0ID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5zdGF0dXMudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgcmVqZWN0KHRoaXMuc3RhdHVzLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gIH1cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHZhciBfYTk7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicmVzb2x2ZWRcIiwgdmFsdWUgfTtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAoX2E5ID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hOS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVqZWN0KGVycm9yKSB7XG4gICAgdmFyIF9hOTtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZWplY3RlZFwiLCBlcnJvciB9O1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIChfYTkgPSB0aGlzLl9yZWplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTkuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvYXN5bmMtaXRlcmFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHNvdXJjZSwgdHJhbnNmb3JtZXIpIHtcbiAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBzb3VyY2UucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcilcbiAgKTtcbiAgdHJhbnNmb3JtZWRTdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IHRyYW5zZm9ybWVkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9IDogeyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtZWRTdHJlYW07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBvbkZpbmlzaCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2E5ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2E5IDogZmFsc2UgfSk7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLnN0cmVhbU9iamVjdFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNjaGVtYVwiOiB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShzY2hlbWEuanNvblNjaGVtYSkgfSxcbiAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxsT3B0aW9ucztcbiAgICAgIGxldCB0cmFuc2Zvcm1lcjtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgICAgIHN5c3RlbTogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHN5c3RlbSA6IGluamVjdEpzb25TY2hlbWFJbnRvU3lzdGVtKHtcbiAgICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYS5qc29uU2NoZW1hXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSAhPSBudWxsID8gc2NoZW1hTmFtZSA6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsID8gc2NoZW1hRGVzY3JpcHRpb24gOiBcIlJlc3BvbmQgd2l0aCBhIEpTT04gb2JqZWN0LlwiLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHNjaGVtYS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJsc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5hcmdzVGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZXN1bHQ6IHsgc3RyZWFtLCB3YXJuaW5ncywgcmF3UmVzcG9uc2UgfSxcbiAgICAgICAgZG9TdHJlYW1TcGFuXG4gICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjYWxsT3B0aW9ucy5pbnB1dEZvcm1hdFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGNhbGxPcHRpb25zLnByb21wdClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucyksXG4gICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjJcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCh7XG4gICAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpKSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICByb290U3BhbixcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICB0ZWxlbWV0cnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0cmVhbSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZSxcbiAgICBzY2hlbWEsXG4gICAgb25GaW5pc2gsXG4gICAgcm9vdFNwYW4sXG4gICAgZG9TdHJlYW1TcGFuLFxuICAgIHRlbGVtZXRyeVxuICB9KSB7XG4gICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSByYXdSZXNwb25zZTtcbiAgICB0aGlzLm9iamVjdFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVVc2FnZSwgcHJvbWlzZTogdXNhZ2VQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZVByb21pc2U7XG4gICAgbGV0IHVzYWdlO1xuICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgbGV0IG9iamVjdDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IGRlbHRhID0gXCJcIjtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgIGxldCBmaXJzdENodW5rID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmIChmaXJzdENodW5rKSB7XG4gICAgICAgICAgICBmaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgZGVsdGEgKz0gY2h1bms7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50T2JqZWN0ID0gcGFyc2VQYXJ0aWFsSnNvbihcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCBjdXJyZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICBsYXRlc3RPYmplY3QgPSBjdXJyZW50T2JqZWN0O1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBjdXJyZW50T2JqZWN0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRleHREZWx0YTogZGVsdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGRlbHRhID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGRlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiBkZWx0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgdXNhZ2UgPSBjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZShjaHVuay51c2FnZSk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IC4uLmNodW5rLCB1c2FnZSB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVVzYWdlKHVzYWdlKTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlc29sdmUob2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGZpbmFsVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLnByb21wdF90b2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgIHdhcm5pbmdzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGdldCBvYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLm9iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICB2YXIgX2E5O1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZCgoX2E5ID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTkgOiAyMDAsIHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVhZCgpO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2E5O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgICAgc3RhdHVzOiAoX2E5ID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTkgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QgPSBzdHJlYW1PYmplY3Q7XG5cbi8vIGNvcmUvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPiAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sczogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWU5LCB0b29sMl0pID0+ICh7XG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICBuYW1lOiBuYW1lOSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0b29sMi5kZXNjcmlwdGlvbixcbiAgICAgIHBhcmFtZXRlcnM6IGFzU2NoZW1hKHRvb2wyLnBhcmFtZXRlcnMpLmpzb25TY2hlbWFcbiAgICB9KSksXG4gICAgdG9vbENob2ljZTogdG9vbENob2ljZSA9PSBudWxsID8geyB0eXBlOiBcImF1dG9cIiB9IDogdHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfSA6IHsgdHlwZTogXCJ0b29sXCIsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3Rvb2wtY2FsbC50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGVycm9ycy9pbnZhbGlkLXRvb2wtYXJndW1lbnRzLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I3LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTcgPSBcIkFJX0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I3IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xBcmdzLFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBhcmd1bWVudHMgZm9yIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlMyhcbiAgICAgIGNhdXNlXG4gICAgKX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTcgJiYgdHlwZW9mIGVycm9yLnRvb2xOYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci50b29sQXJncyA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0aGlzLnRvb2xBcmdzXG4gICAgfTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIGVycm9ycy9uby1zdWNoLXRvb2wtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjggfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU4ID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIE5vU3VjaFRvb2xFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB2b2lkIDAsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHthdmFpbGFibGVUb29scyA9PT0gdm9pZCAwID8gXCJObyB0b29scyBhcmUgYXZhaWxhYmxlLlwiIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKFwiLCBcIil9LmB9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZVRvb2xzID0gYXZhaWxhYmxlVG9vbHM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjguaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hUb29sRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOCAmJiBcInRvb2xOYW1lXCIgaW4gZXJyb3IgJiYgZXJyb3IudG9vbE5hbWUgIT0gdm9pZCAwICYmIHR5cGVvZiBlcnJvci5uYW1lID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiB0aGlzLmF2YWlsYWJsZVRvb2xzXG4gICAgfTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90b29sLWNhbGwudHNcbmZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lIH0pO1xuICB9XG4gIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTjIoe1xuICAgIHRleHQ6IHRvb2xDYWxsLmFyZ3MsXG4gICAgc2NoZW1hOiBhc1NjaGVtYSh0b29sMi5wYXJhbWV0ZXJzKVxuICB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0LnZhbHVlXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heEF1dG9tYXRpY1JvdW5kdHJpcHMgPSAwLFxuICBtYXhUb29sUm91bmR0cmlwcyA9IG1heEF1dG9tYXRpY1JvdW5kdHJpcHMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2E5ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2E5IDogZmFsc2UgfSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4VG9vbFJvdW5kdHJpcHNcIjogbWF4VG9vbFJvdW5kdHJpcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExMCwgX2IsIF9jLCBfZDtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2RlID0ge1xuICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlIH0pXG4gICAgICB9O1xuICAgICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgIH0pO1xuICAgICAgbGV0IGN1cnJlbnRNb2RlbFJlc3BvbnNlO1xuICAgICAgbGV0IGN1cnJlbnRUb29sQ2FsbHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50VG9vbFJlc3VsdHMgPSBbXTtcbiAgICAgIGxldCByb3VuZHRyaXBDb3VudCA9IDA7XG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgICBjb25zdCByb3VuZHRyaXBzID0gW107XG4gICAgICBjb25zdCB1c2FnZSA9IHtcbiAgICAgICAgY29tcGxldGlvblRva2VuczogMCxcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgY3VycmVudElucHV0Rm9ybWF0ID0gcm91bmR0cmlwQ291bnQgPT09IDAgPyB2YWxpZGF0ZWRQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIjtcbiAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHsgaW5wdXQ6ICgpID0+IGN1cnJlbnRJbnB1dEZvcm1hdCB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgLi4uY2FsbFNldHRpbmdzLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBjdXJyZW50SW5wdXRGb3JtYXQsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0LnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gcmVzdWx0LnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdC50b29sQ2FsbHMpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdC5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbENhbGxzID0gKChfYTEwID0gY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKSAhPSBudWxsID8gX2ExMCA6IFtdKS5tYXAoXG4gICAgICAgICAgKG1vZGVsVG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoeyB0b29sQ2FsbDogbW9kZWxUb29sQ2FsbCwgdG9vbHMgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzID0gdG9vbHMgPT0gbnVsbCA/IFtdIDogYXdhaXQgZXhlY3V0ZVRvb2xzKHtcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VycmVudFVzYWdlID0gY2FsY3VsYXRlQ29tcGxldGlvblRva2VuVXNhZ2UoXG4gICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2VcbiAgICAgICAgKTtcbiAgICAgICAgdXNhZ2UuY29tcGxldGlvblRva2VucyArPSBjdXJyZW50VXNhZ2UuY29tcGxldGlvblRva2VucztcbiAgICAgICAgdXNhZ2UucHJvbXB0VG9rZW5zICs9IGN1cnJlbnRVc2FnZS5wcm9tcHRUb2tlbnM7XG4gICAgICAgIHVzYWdlLnRvdGFsVG9rZW5zICs9IGN1cnJlbnRVc2FnZS50b3RhbFRva2VucztcbiAgICAgICAgcm91bmR0cmlwcy5wdXNoKHtcbiAgICAgICAgICB0ZXh0OiAoX2IgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiLFxuICAgICAgICAgIHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscyxcbiAgICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgIHVzYWdlOiBjdXJyZW50VXNhZ2UsXG4gICAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgIGxvZ3Byb2JzOiBjdXJyZW50TW9kZWxSZXNwb25zZS5sb2dwcm9ic1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3UmVzcG9uc2VNZXNzYWdlcyA9IHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgdGV4dDogKF9jID0gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dCkgIT0gbnVsbCA/IF9jIDogXCJcIixcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0c1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKC4uLm5ld1Jlc3BvbnNlTWVzc2FnZXMpO1xuICAgICAgICBwcm9tcHRNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgIC4uLm5ld1Jlc3BvbnNlTWVzc2FnZXMubWFwKFxuICAgICAgICAgICAgKG1lc3NhZ2UpID0+IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIG51bGwpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSB3aGlsZSAoXG4gICAgICAgIC8vIHRoZXJlIGFyZSB0b29sIGNhbGxzOlxuICAgICAgICBjdXJyZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgIGN1cnJlbnRUb29sUmVzdWx0cy5sZW5ndGggPT09IGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoICYmIC8vIHRoZSBudW1iZXIgb2Ygcm91bmR0cmlwcyBpcyBsZXNzIHRoYW4gdGhlIG1heGltdW06XG4gICAgICAgIHJvdW5kdHJpcENvdW50KysgPCBtYXhUb29sUm91bmR0cmlwc1xuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGEgc3RyaW5nIHNvIHRoYXQgdGhlIGNhbGxlciBkb2Vzbid0IGhhdmUgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZC5cbiAgICAgICAgLy8gSWYgdGhleSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb2RlbCBkaWQgbm90IHJldHVybiBhbnkgdGV4dCxcbiAgICAgICAgLy8gdGhleSBjYW4gY2hlY2sgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nOlxuICAgICAgICB0ZXh0OiAoX2QgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2QgOiBcIlwiLFxuICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZTogY3VycmVudE1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UsXG4gICAgICAgIGxvZ3Byb2JzOiBjdXJyZW50TW9kZWxSZXNwb25zZS5sb2dwcm9icyxcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlcyxcbiAgICAgICAgcm91bmR0cmlwc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29scyh7XG4gIHRvb2xDYWxscyxcbiAgdG9vbHMsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChhc3luYyAodG9vbENhbGwpID0+IHtcbiAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhlY3V0ZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodG9vbENhbGwuYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICB0cmFjZXIsXG4gICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0MilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICByZXN1bHRcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIHRvb2xSZXN1bHRzLmZpbHRlcihcbiAgICAocmVzdWx0KSA9PiByZXN1bHQgIT0gbnVsbFxuICApO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy50b29sQ2FsbHMgPSBvcHRpb25zLnRvb2xDYWxscztcbiAgICB0aGlzLnRvb2xSZXN1bHRzID0gb3B0aW9ucy50b29sUmVzdWx0cztcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICAgIHRoaXMucmVzcG9uc2VNZXNzYWdlcyA9IG9wdGlvbnMucmVzcG9uc2VNZXNzYWdlcztcbiAgICB0aGlzLnJvdW5kdHJpcHMgPSBvcHRpb25zLnJvdW5kdHJpcHM7XG4gIH1cbn07XG5mdW5jdGlvbiB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICB0ZXh0LFxuICB0b29sQ2FsbHMsXG4gIHRvb2xSZXN1bHRzXG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0IH0sIC4uLnRvb2xDYWxsc11cbiAgfSk7XG4gIGlmICh0b29sUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgY29udGVudDogdG9vbFJlc3VsdHMubWFwKChyZXN1bHQpID0+ICh7XG4gICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgdG9vbENhbGxJZDogcmVzdWx0LnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiByZXN1bHQudG9vbE5hbWUsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0LnJlc3VsdFxuICAgICAgfSkpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCA9IGdlbmVyYXRlVGV4dDtcblxuLy8gY29yZS91dGlsL21lcmdlLXN0cmVhbXMudHNcbmZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhzdHJlYW0xLCBzdHJlYW0yKSB7XG4gIGNvbnN0IHJlYWRlcjEgPSBzdHJlYW0xLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkZXIyID0gc3RyZWFtMi5nZXRSZWFkZXIoKTtcbiAgbGV0IGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgbGV0IHN0cmVhbTFEb25lID0gZmFsc2U7XG4gIGxldCBzdHJlYW0yRG9uZSA9IGZhbHNlO1xuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMShjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDEgPSByZWFkZXIxLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMTtcbiAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMihjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDIgPSByZWFkZXIyLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMjtcbiAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdHJlYW0xRG9uZSkge1xuICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtMkRvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMiA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXN1bHQsIHJlYWRlciB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBsYXN0UmVhZDEudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjEgfSkpLFxuICAgICAgICAgIGxhc3RSZWFkMi50aGVuKChyZXN1bHQyKSA9PiAoeyByZXN1bHQ6IHJlc3VsdDIsIHJlYWRlcjogcmVhZGVyMiB9KSlcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGVyID09PSByZWFkZXIxKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTIoY29udHJvbGxlcik7XG4gICAgICAgICAgICBzdHJlYW0xRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN0cmVhbTJEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZWFkZXIxLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyMi5jYW5jZWwoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZVRvb2xDYWxscyA9IHt9O1xuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgIGlmICh0b29sQ2FsbFN0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0pIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gY2h1bmsudG9vbE5hbWU7XG4gICAgICAgICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmssXG4gICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0b29sQ2FsbCk7XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25JZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sQ2FsbHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjaHVuay5sb2dwcm9icyxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZShjaHVuay51c2FnZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgaWYgKG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Rvb2xDYWxsU3RyZWFtaW5nOiB0b29sQ2FsbFN0cmVhbWluZyA9IGZhbHNlLFxuICBvbkZpbmlzaCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHsgaXNFbmFibGVkOiAoX2E5ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPSBudWxsID8gX2E5IDogZmFsc2UgfSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnN0cmVhbVRleHRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uTmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICBmbjogYXN5bmMgKHJvb3RTcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSk7XG4gICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHNcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXN1bHQ6IHsgc3RyZWFtLCB3YXJuaW5ncywgcmF3UmVzcG9uc2UgfSxcbiAgICAgICAgZG9TdHJlYW1TcGFuXG4gICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbGlkYXRlZFByb21wdC50eXBlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgICAgICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSB9KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0KHtcbiAgICAgICAgc3RyZWFtOiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBnZW5lcmF0b3JTdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICByb290U3BhbixcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICB0ZWxlbWV0cnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgb25GaW5pc2gsXG4gICAgcm9vdFNwYW4sXG4gICAgZG9TdHJlYW1TcGFuLFxuICAgIHRlbGVtZXRyeVxuICB9KSB7XG4gICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSByYXdSZXNwb25zZTtcbiAgICB0aGlzLm9uRmluaXNoID0gb25GaW5pc2g7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZUZpbmlzaFJlYXNvbiwgcHJvbWlzZTogZmluaXNoUmVhc29uUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvblByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVGV4dCwgcHJvbWlzZTogdGV4dFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50ZXh0ID0gdGV4dFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVG9vbENhbGxzLCBwcm9taXNlOiB0b29sQ2FsbHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbENhbGxzID0gdG9vbENhbGxzUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUb29sUmVzdWx0cywgcHJvbWlzZTogdG9vbFJlc3VsdHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSB0b29sUmVzdWx0c1Byb21pc2U7XG4gICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICBsZXQgdXNhZ2U7XG4gICAgbGV0IHRleHQgPSBcIlwiO1xuICAgIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICAgIGNvbnN0IHRvb2xSZXN1bHRzID0gW107XG4gICAgbGV0IGZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBpZiAoZmlyc3RDaHVuaykge1xuICAgICAgICAgICAgZmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgIHRleHQgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjpcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOlxuICAgICAgICAgICAgICB0b29sUmVzdWx0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIHVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgcmVzb2x2ZVVzYWdlKHVzYWdlKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZUZpbmlzaFJlYXNvbihmaW5pc2hSZWFzb24pO1xuICAgICAgICAgICAgICByZXNvbHZlVGV4dCh0ZXh0KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVRvb2xDYWxscyh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCI6XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdmFyIF9hOTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmluYWxVc2FnZSA9IHVzYWdlICE9IG51bGwgPyB1c2FnZSA6IHtcbiAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IE5hTlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsRmluaXNoUmVhc29uID0gZmluaXNoUmVhc29uICE9IG51bGwgPyBmaW5pc2hSZWFzb24gOiBcInVua25vd25cIjtcbiAgICAgICAgICAgIGNvbnN0IHRlbGVtZXRyeVRvb2xDYWxscyA9IHRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkodG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogZmluYWxGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiBmaW5hbFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiB0ZXh0IH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjogeyBvdXRwdXQ6ICgpID0+IHRlbGVtZXRyeVRvb2xDYWxscyB9LFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmFsRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLnByb21wdF90b2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmVuZCgpO1xuICAgICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmFsRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gdGV4dCB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHsgb3V0cHV0OiAoKSA9PiB0ZWxlbWV0cnlUb29sQ2FsbHMgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlVG9vbFJlc3VsdHModG9vbFJlc3VsdHMpO1xuICAgICAgICAgICAgYXdhaXQgKChfYTkgPSBzZWxmLm9uRmluaXNoKSA9PSBudWxsID8gdm9pZCAwIDogX2E5LmNhbGwoc2VsZiwge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGZpbmFsRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAvLyBUaGUgdG9vbCByZXN1bHRzIGFyZSBpbmZlcnJlZCBhcyBhIG5ldmVyW10gdHlwZSwgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBvcHRpb25hbCBhbmQgdGhlIGV4ZWN1dGUgbWV0aG9kIHdpdGggYW4gaW5mZXJyZWQgcmVzdWx0IHR5cGUgaXNcbiAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYXMgd2VsbC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gY2FzdCB0aGUgdG9vbFJlc3VsdHMgdG8gYW55LlxuICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBleHBvc2VkIHRvIHRoZSB1c2VycyB3aWxsIGJlIGNvcnJlY3RseSBpbmZlcnJlZC5cbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHMsXG4gICAgICAgICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgICB3YXJuaW5nc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcm9vdFNwYW4uZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLm9yaWdpbmFsU3RyZWFtLnRlZSgpO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0yO1xuICAgIHJldHVybiBzdHJlYW0xO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsudGV4dERlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsudGV4dERlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0b0FJU3RyZWFtKGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRhU3RyZWFtKHsgY2FsbGJhY2tzIH0pO1xuICB9XG4gIHRvRGF0YVN0cmVhbSh7XG4gICAgY2FsbGJhY2tzID0ge30sXG4gICAgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U0ID0gKCkgPT4gXCJcIlxuICAgIC8vIG1hc2sgZXJyb3IgbWVzc2FnZXMgZm9yIHNhZmV0eSBieSBkZWZhdWx0XG4gIH0gPSB7fSkge1xuICAgIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IGNhbGxiYWNrVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgY29uc3QgdGV4dERlbHRhID0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSB0ZXh0RGVsdGE7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKVxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4odGV4dERlbHRhKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dClcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQodGV4dERlbHRhKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbilcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbClcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBjaHVuay50ZXh0RGVsdGEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfY2FsbF9kZWx0YVwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBjaHVuay5hcmdzVGV4dERlbHRhXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9jYWxsXCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBjaHVuay5hcmdzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX3Jlc3VsdFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGNodW5rLnJlc3VsdFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgZ2V0RXJyb3JNZXNzYWdlNChjaHVuay5lcnJvcikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZmluaXNoX21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZ1bGxTdHJlYW0ucGlwZVRocm91Z2goY2FsbGJhY2tUcmFuc2Zvcm1lcikucGlwZVRocm91Z2goc3RyZWFtUGFydHNUcmFuc2Zvcm1lcikucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICB9XG4gIHBpcGVBSVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5waXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpO1xuICB9XG4gIHBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHZhciBfYTk7XG4gICAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYTkgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hOSA6IDIwMCwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnRvRGF0YVN0cmVhbSgpLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWFkKCk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hOTtcbiAgICByZXNwb25zZS53cml0ZUhlYWQoKF9hOSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2E5IDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWQoKTtcbiAgfVxuICB0b0FJU3RyZWFtUmVzcG9uc2Uob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvRGF0YVN0cmVhbVJlc3BvbnNlKG9wdGlvbnMpO1xuICB9XG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E5O1xuICAgIGNvbnN0IGluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImluaXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pbml0IDoge1xuICAgICAgaGVhZGVyczogXCJoZWFkZXJzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaGVhZGVycyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1czogXCJzdGF0dXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiB2b2lkIDAsXG4gICAgICBzdGF0dXNUZXh0OiBcInN0YXR1c1RleHRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJkYXRhXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcbiAgICBjb25zdCBnZXRFcnJvck1lc3NhZ2U0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJnZXRFcnJvck1lc3NhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UgOiB2b2lkIDA7XG4gICAgY29uc3Qgc3RyZWFtID0gZGF0YSA/IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgdGhpcy50b0RhdGFTdHJlYW0oeyBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTQgfSkpIDogdGhpcy50b0RhdGFTdHJlYW0oeyBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTQgfSk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcbiAgICAgIHN0YXR1czogKF9hOSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2E5IDogMjAwLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hOTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hOSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2E5IDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfc3RyZWFtVGV4dCA9IHN0cmVhbVRleHQ7XG5cbi8vIGNvcmUvcHJvbXB0L2F0dGFjaG1lbnRzLXRvLXBhcnRzLnRzXG5mdW5jdGlvbiBhdHRhY2htZW50c1RvUGFydHMoYXR0YWNobWVudHMpIHtcbiAgdmFyIF9hOSwgX2IsIF9jO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgYXR0YWNobWVudHMpIHtcbiAgICBsZXQgdXJsO1xuICAgIHRyeSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKGF0dGFjaG1lbnQudXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICB9XG4gICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgY2FzZSBcImh0dHBzOlwiOiB7XG4gICAgICAgIGlmICgoX2E5ID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hOS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhOlwiOiB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGxldCBiYXNlNjRDb250ZW50O1xuICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBhdHRhY2htZW50LnVybC5zcGxpdChcIixcIik7XG4gICAgICAgICAgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2MgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KFxuICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHtcbiAgICByb2xlLFxuICAgIGNvbnRlbnQsXG4gICAgdG9vbEludm9jYXRpb25zLFxuICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50c1xuICB9IG9mIG1lc3NhZ2VzKSB7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBleHBlcmltZW50YWxfYXR0YWNobWVudHMgPyBbXG4gICAgICAgICAgICB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAuLi5hdHRhY2htZW50c1RvUGFydHMoZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzKVxuICAgICAgICAgIF0gOiBjb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBpZiAodG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwiYXNzaXN0YW50XCIsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4udG9vbEludm9jYXRpb25zLm1hcCgoeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgYXJncyB9KSA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHRvb2xJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAoeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgYXJncywgcmVzdWx0IH0pID0+ICh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcmVNZXNzYWdlcztcbn1cblxuLy8gY29yZS9yZWdpc3RyeS9pbnZhbGlkLW1vZGVsLWlkLWVycm9yLnRzXG52YXIgSW52YWxpZE1vZGVsSWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaWQsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIG1vZGVsIGlkOiAke2lkfWBcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiQUlfSW52YWxpZE1vZGVsSWRFcnJvclwiO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuICBzdGF0aWMgaXNJbnZhbGlkTW9kZWxJZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBSV9JbnZhbGlkTW9kZWxJZEVycm9yXCIgJiYgdHlwZW9mIGVycm9yLmlkID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBpZDogdGhpcy5pZFxuICAgIH07XG4gIH1cbn07XG5cbi8vIGNvcmUvcmVnaXN0cnkvbm8tc3VjaC1tb2RlbC1lcnJvci50c1xudmFyIE5vU3VjaE1vZGVsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCAke21vZGVsVHlwZX06ICR7bW9kZWxJZH1gXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMubW9kZWxUeXBlID0gbW9kZWxUeXBlO1xuICB9XG4gIHN0YXRpYyBpc05vU3VjaE1vZGVsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIiAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IubW9kZWxUeXBlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtb2RlbFR5cGU6IHRoaXMubW9kZWxUeXBlXG4gICAgfTtcbiAgfVxufTtcblxuLy8gY29yZS9yZWdpc3RyeS9uby1zdWNoLXByb3ZpZGVyLWVycm9yLnRzXG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcHJvdmlkZXJJZCxcbiAgICBhdmFpbGFibGVQcm92aWRlcnMsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoIHByb3ZpZGVyOiAke3Byb3ZpZGVySWR9IChhdmFpbGFibGUgcHJvdmlkZXJzOiAke2F2YWlsYWJsZVByb3ZpZGVycy5qb2luKCl9KWBcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiQUlfTm9TdWNoUHJvdmlkZXJFcnJvclwiO1xuICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgdGhpcy5hdmFpbGFibGVQcm92aWRlcnMgPSBhdmFpbGFibGVQcm92aWRlcnM7XG4gIH1cbiAgc3RhdGljIGlzTm9TdWNoUHJvdmlkZXJFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiQUlfTm9TdWNoUHJvdmlkZXJFcnJvclwiICYmIHR5cGVvZiBlcnJvci5wcm92aWRlcklkID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZXJyb3IuYXZhaWxhYmxlUHJvdmlkZXJzKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiB0aGlzLmF2YWlsYWJsZVByb3ZpZGVyc1xuICAgIH07XG4gIH1cbn07XG5cbi8vIGNvcmUvcmVnaXN0cnkvcHJvdmlkZXItcmVnaXN0cnkudHNcbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5KHByb3ZpZGVycykge1xuICBjb25zdCByZWdpc3RyeSA9IG5ldyBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSgpO1xuICBmb3IgKGNvbnN0IFtpZCwgcHJvdmlkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVycykpIHtcbiAgICByZWdpc3RyeS5yZWdpc3RlclByb3ZpZGVyKHsgaWQsIHByb3ZpZGVyIH0pO1xuICB9XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbnZhciBleHBlcmltZW50YWxfY3JlYXRlTW9kZWxSZWdpc3RyeSA9IGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICB9XG4gIHJlZ2lzdGVyUHJvdmlkZXIoeyBpZCwgcHJvdmlkZXIgfSkge1xuICAgIHRoaXMucHJvdmlkZXJzW2lkXSA9IHByb3ZpZGVyO1xuICB9XG4gIGdldFByb3ZpZGVyKGlkKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyc1tpZF07XG4gICAgaWYgKHByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hQcm92aWRlckVycm9yKHtcbiAgICAgICAgcHJvdmlkZXJJZDogaWQsXG4gICAgICAgIGF2YWlsYWJsZVByb3ZpZGVyczogT2JqZWN0LmtleXModGhpcy5wcm92aWRlcnMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xuICB9XG4gIHNwbGl0SWQoaWQpIHtcbiAgICBjb25zdCBpbmRleCA9IGlkLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTW9kZWxJZEVycm9yKHsgaWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaWQuc2xpY2UoMCwgaW5kZXgpLCBpZC5zbGljZShpbmRleCArIDEpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hOSwgX2I7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYiA9IChfYTkgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpKS5sYW5ndWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTksIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcih7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2UgbW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRleHRFbWJlZGRpbmdNb2RlbChpZCkge1xuICAgIHZhciBfYTksIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCk7XG4gICAgY29uc3QgbW9kZWwgPSAoX2IgPSAoX2E5ID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKSkudGV4dEVtYmVkZGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2E5LCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRleHQgZW1iZWRkaW5nIG1vZGVsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbn07XG5cbi8vIGNvcmUvdG9vbC90b29sLnRzXG5mdW5jdGlvbiB0b29sKHRvb2wyKSB7XG4gIHJldHVybiB0b29sMjtcbn1cblxuLy8gY29yZS91dGlsL2Nvc2luZS1zaW1pbGFyaXR5LnRzXG5mdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBWZWN0b3JzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggKHZlY3RvcjE6ICR7dmVjdG9yMS5sZW5ndGh9IGVsZW1lbnRzLCB2ZWN0b3IyOiAke3ZlY3RvcjIubGVuZ3RofSBlbGVtZW50cylgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSAvIChtYWduaXR1ZGUodmVjdG9yMSkgKiBtYWduaXR1ZGUodmVjdG9yMikpO1xufVxuZnVuY3Rpb24gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIHJldHVybiB2ZWN0b3IxLnJlZHVjZShcbiAgICAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCkgPT4gYWNjdW11bGF0b3IgKyB2YWx1ZSAqIHZlY3RvcjJbaW5kZXhdLFxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hZ25pdHVkZSh2ZWN0b3IpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkb3RQcm9kdWN0KHZlY3RvciwgdmVjdG9yKSk7XG59XG5cbi8vIGVycm9ycy9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOSxcbiAgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHN0cmVhbXMvYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVQYXJzZXJcbn0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlclwiO1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpIHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCAmJiBldmVudC50eXBlID09PSBcImV2ZW50XCIgJiYgZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIiB8fCAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICBldmVudC5ldmVudCA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlciA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhLCB7XG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudFxuICAgICAgICAgICAgfSkgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpKTtcbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBjb250ZW50O1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbihjb250ZW50KTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0ICYmIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHJldHVybiBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbFwiIGluIGNhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCkge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG4gIHJldHVybiAodGV4dCkgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuZnVuY3Rpb24gQUlTdHJlYW0ocmVzcG9uc2UsIGN1c3RvbVBhcnNlciwgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgdmFyIF9hOTtcbiAgICAgIGF3YWl0ICgoX2E5ID0gaXQucmV0dXJuKSA9PSBudWxsID8gdm9pZCAwIDogX2E5LmNhbGwoaXQsIHJlYXNvbikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbmltcG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xudmFyIFNUUkVBTV9EQVRBX1dBUk5JTkdfVElNRV9NUyA9IDE1ICogMWUzO1xudmFyIFN0cmVhbURhdGEyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLndhcm5pbmdUaW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLnN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogYXN5bmMgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICBzZWxmLndhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgU1RSRUFNX0RBVEFfV0FSTklOR19USU1FX01TKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHB1bGw6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAocmVhc29uKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy53YXJuaW5nVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FybmluZ1RpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBhcHBlbmQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQyKFwiZGF0YVwiLCBbdmFsdWVdKSlcbiAgICApO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcInRleHRcIiwgbWVzc2FnZSkpKTtcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW1EYXRhMiB7XG59O1xuXG4vLyBzdHJlYW1zL2FudGhyb3BpYy1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlQW50aHJvcGljU3RyZWFtKCkge1xuICBsZXQgcHJldmlvdXMgPSBcIlwiO1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBpZiAoXCJlcnJvclwiIGluIGpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtqc29uLmVycm9yLnR5cGV9OiAke2pzb24uZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKCEoXCJjb21wbGV0aW9uXCIgaW4ganNvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGpzb24uY29tcGxldGlvbjtcbiAgICBpZiAoIXByZXZpb3VzIHx8IHRleHQubGVuZ3RoID4gcHJldmlvdXMubGVuZ3RoICYmIHRleHQuc3RhcnRzV2l0aChwcmV2aW91cykpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gdGV4dC5zbGljZShwcmV2aW91cy5sZW5ndGgpO1xuICAgICAgcHJldmlvdXMgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcImNvbXBsZXRpb25cIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rLmNvbXBsZXRpb247XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICB9IGVsc2UgaWYgKFwiZGVsdGFcIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgeyBkZWx0YSB9ID0gY2h1bms7XG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gZGVsdGEpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRlbHRhLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgIHlpZWxkIHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBbnRocm9waWNTdHJlYW0ocmVzLCBjYikge1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQUlTdHJlYW0ocmVzLCBwYXJzZUFudGhyb3BpY1N0cmVhbSgpLCBjYikucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9hc3Npc3RhbnQtcmVzcG9uc2UudHNcbmltcG9ydCB7XG4gIGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDNcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIEFzc2lzdGFudFJlc3BvbnNlKHsgdGhyZWFkSWQsIG1lc3NhZ2VJZCB9LCBwcm9jZXNzMikge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTk7XG4gICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgY29uc3Qgc2VuZE1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiYXNzaXN0YW50X21lc3NhZ2VcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZERhdGFNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJlcnJvclwiLCBlcnJvck1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBhc3luYyAoc3RyZWFtMikgPT4ge1xuICAgICAgICB2YXIgX2ExMCwgX2I7XG4gICAgICAgIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtMikge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5jcmVhdGVkXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQzKFwiYXNzaXN0YW50X21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHsgdmFsdWU6IFwiXCIgfSB9XVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYTEwID0gdmFsdWUuZGF0YS5kZWx0YS5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ExMFswXTtcbiAgICAgICAgICAgICAgaWYgKChjb250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50LnR5cGUpID09PSBcInRleHRcIiAmJiAoKF9iID0gY29udGVudC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQzKFwidGV4dFwiLCBjb250ZW50LnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLmNvbXBsZXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsIHtcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3MyKHtcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgc2VuZERhdGFNZXNzYWdlLFxuICAgICAgICAgIGZvcndhcmRTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZW5kRXJyb3IoKF9hOSA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYTkgOiBgJHtlcnJvcn1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1bGwoY29udHJvbGxlcikge1xuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG4gICAgc3RhdHVzOiAyMDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSA9IEFzc2lzdGFudFJlc3BvbnNlO1xuXG4vLyBzdHJlYW1zL2F3cy1iZWRyb2NrLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICB2YXIgX2E5LCBfYjtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIChfYTkgPSByZXNwb25zZS5ib2R5KSAhPSBudWxsID8gX2E5IDogW10pIHtcbiAgICBjb25zdCBieXRlcyA9IChfYiA9IGNodW5rLmNodW5rKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYnl0ZXM7XG4gICAgaWYgKGJ5dGVzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rVGV4dCA9IGRlY29kZXIuZGVjb2RlKGJ5dGVzKTtcbiAgICAgIGNvbnN0IGNodW5rSlNPTiA9IEpTT04ucGFyc2UoY2h1bmtUZXh0KTtcbiAgICAgIGNvbnN0IGRlbHRhID0gZXh0cmFjdFRleHREZWx0YUZyb21DaHVuayhjaHVua0pTT04pO1xuICAgICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgeWllbGQgZGVsdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljTWVzc2FnZXNTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IHtcbiAgICB2YXIgX2E5O1xuICAgIHJldHVybiAoX2E5ID0gY2h1bmsuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTkudGV4dDtcbiAgfSk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5jb21wbGV0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tDb2hlcmVTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rID09IG51bGwgPyB2b2lkIDAgOiBjaHVuay50ZXh0KTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmdlbmVyYXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKFxuICAgIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaylcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMihyZXMpIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgcmVhZGVyID0gKF9hOSA9IHJlcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2E5LmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUyKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChjaHVuay5ldmVudFR5cGUgPT09IFwidGV4dC1nZW5lcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay50ZXh0O1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBDb2hlcmVTdHJlYW0ocmVhZGVyLCBjYWxsYmFja3MpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlYWRlcikge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUyKHJlYWRlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlUGFyc2VyMihyZWFkZXIpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2dvb2dsZS1nZW5lcmF0aXZlLWFpLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUzKHJlc3BvbnNlKSB7XG4gIHZhciBfYTksIF9iLCBfYztcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZS5zdHJlYW0pIHtcbiAgICBjb25zdCBwYXJ0cyA9IChfYyA9IChfYiA9IChfYTkgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2E5WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnBhcnRzO1xuICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHNbMF07XG4gICAgaWYgKHR5cGVvZiBmaXJzdFBhcnQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgeWllbGQgZmlyc3RQYXJ0LnRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0ocmVzcG9uc2UsIGNiKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUzKHJlc3BvbnNlKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvaHVnZ2luZ2ZhY2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIzKHJlcykge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hOSwgX2I7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZXMubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKF9iID0gKF9hOSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2E5LnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIpO1xuICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodmFsdWUuZ2VuZXJhdGVkX3RleHQgIT0gbnVsbCAmJiB2YWx1ZS5nZW5lcmF0ZWRfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ID09PSBcIjwvcz5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kb2Z0ZXh0fD5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kfD5cIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEh1Z2dpbmdGYWNlU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBjcmVhdGVQYXJzZXIzKHJlcykucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2lua2VlcC1zdHJlYW0udHNcbmZ1bmN0aW9uIElua2VlcFN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2UgYm9keSBpcyBudWxsXCIpO1xuICB9XG4gIGxldCBjaGF0X3Nlc3Npb25faWQgPSBcIlwiO1xuICBsZXQgcmVjb3Jkc19jaXRlZDtcbiAgY29uc3QgaW5rZWVwRXZlbnRQYXJzZXIgPSAoZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfYTksIF9iO1xuICAgIGNvbnN0IHsgZXZlbnQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50ID09PSBcInJlY29yZHNfY2l0ZWRcIikge1xuICAgICAgcmVjb3Jkc19jaXRlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAoX2E5ID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWNvcmRzQ2l0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYTkuY2FsbChjYWxsYmFja3MsIHJlY29yZHNfY2l0ZWQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgPT09IFwibWVzc2FnZV9jaHVua1wiKSB7XG4gICAgICBjb25zdCBpbmtlZXBNZXNzYWdlQ2h1bmsgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgY2hhdF9zZXNzaW9uX2lkID0gKF9iID0gaW5rZWVwTWVzc2FnZUNodW5rLmNoYXRfc2Vzc2lvbl9pZCkgIT0gbnVsbCA/IF9iIDogY2hhdF9zZXNzaW9uX2lkO1xuICAgICAgcmV0dXJuIGlua2VlcE1lc3NhZ2VDaHVuay5jb250ZW50X2NodW5rO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG4gIGxldCB7IG9uUmVjb3Jkc0NpdGVkLCAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyB9ID0gY2FsbGJhY2tzIHx8IHt9O1xuICBwYXNzVGhyb3VnaENhbGxiYWNrcyA9IHtcbiAgICAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyxcbiAgICBvbkZpbmFsOiAoY29tcGxldGlvbikgPT4ge1xuICAgICAgdmFyIF9hOTtcbiAgICAgIGNvbnN0IGlua2VlcE9uRmluYWxNZXRhZGF0YSA9IHtcbiAgICAgICAgY2hhdF9zZXNzaW9uX2lkLFxuICAgICAgICByZWNvcmRzX2NpdGVkXG4gICAgICB9O1xuICAgICAgKF9hOSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRmluYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTkuY2FsbChjYWxsYmFja3MsIGNvbXBsZXRpb24sIGlua2VlcE9uRmluYWxNZXRhZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQUlTdHJlYW0ocmVzLCBpbmtlZXBFdmVudFBhcnNlciwgcGFzc1Rocm91Z2hDYWxsYmFja3MpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLWFkYXB0ZXIudHNcbnZhciBsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzLCB7XG4gIHRvQUlTdHJlYW06ICgpID0+IHRvQUlTdHJlYW0sXG4gIHRvRGF0YVN0cmVhbTogKCkgPT4gdG9EYXRhU3RyZWFtLFxuICB0b0RhdGFTdHJlYW1SZXNwb25zZTogKCkgPT4gdG9EYXRhU3RyZWFtUmVzcG9uc2Vcbn0pO1xuZnVuY3Rpb24gdG9BSVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gdG9EYXRhU3RyZWFtKHN0cmVhbSwgY2FsbGJhY2tzKTtcbn1cbmZ1bmN0aW9uIHRvRGF0YVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAodmFsdWUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgdmFyIF9hOTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImV2ZW50XCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUuZXZlbnQgPT09IFwib25fY2hhdF9tb2RlbF9zdHJlYW1cIikge1xuICAgICAgICAgICAgZm9yd2FyZEFJTWVzc2FnZUNodW5rKFxuICAgICAgICAgICAgICAoX2E5ID0gdmFsdWUuZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hOS5jaHVuayxcbiAgICAgICAgICAgICAgY29udHJvbGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayh2YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgdmFyIF9hOTtcbiAgY29uc3QgZGF0YVN0cmVhbSA9IHRvRGF0YVN0cmVhbShzdHJlYW0sIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FsbGJhY2tzKTtcbiAgY29uc3QgZGF0YSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YTtcbiAgY29uc3QgaW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdDtcbiAgY29uc3QgcmVzcG9uc2VTdHJlYW0gPSBkYXRhID8gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCBkYXRhU3RyZWFtKSA6IGRhdGFTdHJlYW07XG4gIHJldHVybiBuZXcgUmVzcG9uc2UocmVzcG9uc2VTdHJlYW0sIHtcbiAgICBzdGF0dXM6IChfYTkgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hOSA6IDIwMCxcbiAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjaHVuay5jb250ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb250ZW50KSB7XG4gICAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoaXRlbS50ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tc3RyZWFtLnRzXG5mdW5jdGlvbiBMYW5nQ2hhaW5TdHJlYW0oY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICBjb25zdCBydW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIGF3YWl0IHdyaXRlci5hYm9ydChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU3RhcnQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmFkZChydW5JZCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUVuZCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBpZiAocnVucy5zaXplID09PSAwKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpLFxuICAgIHdyaXRlcixcbiAgICBoYW5kbGVyczoge1xuICAgICAgaGFuZGxlTExNTmV3VG9rZW46IGFzeW5jICh0b2tlbikgPT4ge1xuICAgICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICAgIGF3YWl0IHdyaXRlci53cml0ZSh0b2tlbik7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNU3RhcnQ6IGFzeW5jIChfbGxtLCBfcHJvbXB0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5TdGFydDogYXN5bmMgKF9jaGFpbiwgX2lucHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRW5kOiBhc3luYyAoX291dHB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sU3RhcnQ6IGFzeW5jIChfdG9vbCwgX2lucHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3RyZWFtcy9taXN0cmFsLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU0KHN0cmVhbSkge1xuICB2YXIgX2E5LCBfYjtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hOSA9IGNodW5rLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTkuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgIGlmIChjb250ZW50ID09PSB2b2lkIDAgfHwgY29udGVudCA9PT0gXCJcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHlpZWxkIGNvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIE1pc3RyYWxTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU0KHJlc3BvbnNlKSk7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL29wZW5haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgZm9ybWF0U3RyZWFtUGFydCBhcyBmb3JtYXRTdHJlYW1QYXJ0NFxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuZnVuY3Rpb24gcGFyc2VPcGVuQUlTdHJlYW0oKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICByZXR1cm4gKGRhdGEpID0+IGV4dHJhY3QoSlNPTi5wYXJzZShkYXRhKSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTUoc3RyZWFtKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJwcm9tcHRGaWx0ZXJSZXN1bHRzXCIgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IGNodW5rLm9iamVjdCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiBjaHVuay5tb2RlbCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKChjaG9pY2UpID0+IHtcbiAgICAgICAgICB2YXIgX2E5LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgICBjb250ZW50OiAoX2E5ID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2E5LmNvbnRlbnQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IChfYiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgICAgcm9sZTogKF9jID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Mucm9sZSxcbiAgICAgICAgICAgICAgdG9vbF9jYWxsczogKChfZSA9IChfZCA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgPyAoX2cgPSAoX2YgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xDYWxsLnR5cGVcbiAgICAgICAgICAgICAgfSkpIDogdm9pZCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogY2hvaWNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuICAgIGlmICh0ZXh0KVxuICAgICAgeWllbGQgdGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbjtcbiAgcmV0dXJuIChqc29uKSA9PiB7XG4gICAgdmFyIF9hOSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yO1xuICAgIGlmIChpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gKF9hOSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hOS5kZWx0YTtcbiAgICAgIGlmICgoX2IgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogYHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcIiR7ZGVsdGEuZnVuY3Rpb25fY2FsbC5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9lID0gKF9kID0gKF9jID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZS5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZiA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2YubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9nID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfaCA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9pID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9sID0gKF9rID0gKF9qID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9qWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2suZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9vID0gKF9uID0gKF9tID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX24uZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfby5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfcCA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9xID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3EuZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19J1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKChfciA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yLmZpbmlzaF9yZWFzb24pID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19XX0nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50IDogaXNDb21wbGV0aW9uKGpzb24pID8ganNvbi5jaG9pY2VzWzBdLnRleHQgOiBcIlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rKSB7XG4gICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cbnZhciBfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sID0gU3ltYm9sKFxuICBcImludGVybmFsX29wZW5haV9mbl9tZXNzYWdlc1wiXG4pO1xuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcImRlbHRhXCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcInRleHRcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBPcGVuQUlTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgY2IgPSBjYWxsYmFja3M7XG4gIGxldCBzdHJlYW07XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU1KHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgICAuLi5jYixcbiAgICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5jYlxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgIC4uLmNiLFxuICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoY2IgJiYgKGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICBjb25zdCBmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNiKTtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IFwiXCI7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPSBpc0ZpcnN0Q2h1bmsgJiYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8IG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKTtcbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0NChcInRleHRcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0ge1xuICAgICAgICAgICAgICB0b29sczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wyIG9mIHBheWxvYWQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMudG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sMi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wyLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbChcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZUluZGV4ID09PSAwID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyBhbiBvYmplY3QgdG8gdGhlIHVzZXIsIGJ1dCBhcyB0aGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcsIHdlIG5lZWQgdG8gc3RyaW5naWZ5IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsbGluZyBleHBlcmltZW50YWxfb25Ub29sQ2FsbDpcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDQoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPyBcImZ1bmN0aW9uX2NhbGxcIiA6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdG8gcHJldmVudCBkb3VibGUtZW5jb2Rpbmc6XG4gICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDQoXCJ0ZXh0XCIsIGZ1bmN0aW9uUmVzcG9uc2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHZvaWQgMDtcbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3JlcGxpY2F0ZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIFJlcGxpY2F0ZVN0cmVhbShyZXMsIGNiLCBvcHRpb25zKSB7XG4gIHZhciBfYTk7XG4gIGNvbnN0IHVybCA9IChfYTkgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hOS5zdHJlYW07XG4gIGlmICghdXJsKSB7XG4gICAgaWYgKHJlcy5lcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuZXJyb3IpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RyZWFtIFVSTCBpbiBSZXBsaWNhdGUgcmVzcG9uc2VcIik7XG4gIH1cbiAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBcInRleHQvZXZlbnQtc3RyZWFtXCIsXG4gICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQUlTdHJlYW0oZXZlbnRTdHJlYW0sIHZvaWQgMCwgY2IpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBzdHJlYW1Ub1Jlc3BvbnNlKHJlcywgcmVzcG9uc2UsIGluaXQsIGRhdGEpIHtcbiAgdmFyIF9hOTtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYTkgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hOSA6IDIwMCwge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICB9KTtcbiAgbGV0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcztcbiAgaWYgKGRhdGEpIHtcbiAgICBwcm9jZXNzZWRTdHJlYW0gPSBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIHJlcyk7XG4gIH1cbiAgY29uc3QgcmVhZGVyID0gcHJvY2Vzc2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgcmVhZCgpO1xuICAgIH0pO1xuICB9XG4gIHJlYWQoKTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW1pbmctdGV4dC1yZXNwb25zZS50c1xudmFyIFN0cmVhbWluZ1RleHRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXMsIGluaXQsIGRhdGEpIHtcbiAgICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBwcm9jZXNzZWRTdHJlYW0gPSBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIHJlcyk7XG4gICAgfVxuICAgIHN1cGVyKHByb2Nlc3NlZFN0cmVhbSwge1xuICAgICAgLi4uaW5pdCxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3RyZWFtcy9pbmRleC50c1xudmFyIGdlbmVyYXRlSWQyID0gZ2VuZXJhdGVJZEltcGw7XG52YXIgbmFub2lkID0gZ2VuZXJhdGVJZEltcGw7XG5leHBvcnQge1xuICBBSVNES0Vycm9yOSBhcyBBSVNES0Vycm9yLFxuICBBSVN0cmVhbSxcbiAgQVBJQ2FsbEVycm9yMiBhcyBBUElDYWxsRXJyb3IsXG4gIEFXU0JlZHJvY2tBbnRocm9waWNNZXNzYWdlc1N0cmVhbSxcbiAgQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbSxcbiAgQVdTQmVkcm9ja0NvaGVyZVN0cmVhbSxcbiAgQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSxcbiAgQVdTQmVkcm9ja1N0cmVhbSxcbiAgQW50aHJvcGljU3RyZWFtLFxuICBBc3Npc3RhbnRSZXNwb25zZSxcbiAgQ29oZXJlU3RyZWFtLFxuICBEb3dubG9hZEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0sXG4gIEh1Z2dpbmdGYWNlU3RyZWFtLFxuICBJbmtlZXBTdHJlYW0sXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IsXG4gIEludmFsaWRNb2RlbElkRXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcjIgYXMgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzIGFzIExhbmdDaGFpbkFkYXB0ZXIsXG4gIExhbmdDaGFpblN0cmVhbSxcbiAgTG9hZEFQSUtleUVycm9yLFxuICBNaXN0cmFsU3RyZWFtLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIE9wZW5BSVN0cmVhbSxcbiAgUmVwbGljYXRlU3RyZWFtLFxuICBSZXRyeUVycm9yLFxuICBTdHJlYW1EYXRhMiBhcyBTdHJlYW1EYXRhLFxuICBTdHJlYW1pbmdUZXh0UmVzcG9uc2UsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyxcbiAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VG9Db3JlTWVzc2FnZXMsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9UZXh0LFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcixcbiAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyLFxuICBlbWJlZCxcbiAgZW1iZWRNYW55LFxuICBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhLFxuICBleHBlcmltZW50YWxfY3JlYXRlTW9kZWxSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbVRleHQsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQyIGFzIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGpzb25TY2hlbWEsXG4gIG5hbm9pZCxcbiAgcGFyc2VDb21wbGV4UmVzcG9uc2UsXG4gIHBhcnNlU3RyZWFtUGFydCxcbiAgcmVhZERhdGFTdHJlYW0sXG4gIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUsXG4gIHN0cmVhbU9iamVjdCxcbiAgc3RyZWFtVGV4dCxcbiAgc3RyZWFtVG9SZXNwb25zZSxcbiAgdG9vbCxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_4___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(action-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(action-browser)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsondiffpatch */ \"(action-browser)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(action-browser)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"(action-browser)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventsource-parser */ \"(action-browser)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(action-browser)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(action-browser)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"45e4555d644c409f5a3230e473941a60df6485a1\":\"$$ACTION_0\"} */ \n\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a8, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a8 = store.options).onSetAIState) == null ? void 0 : _b.call(_a8, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/create-suspended-chunk.tsx\n\n\nvar R = [\n    async ({ c: current, n: next })=>{\n        const chunk = await next;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {\n                children: [\n                    current,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspendedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\n// rsc/streamable.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspendedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    const streamable2 = {\n        value: row,\n        update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return streamable2;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return streamable2;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable value has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable2 = {\n        set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        get value () {\n            return createWrapped(true);\n        },\n        update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable2;\n            }\n            resolvable.resolve({});\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\n// rsc/render.ts\n\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name,\n            message\n        });\n        this[_a] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isRetryError(error) {\n        return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            reason: this.reason,\n            lastError: this.lastError,\n            errors: this.errors\n        };\n    }\n};\n_a = symbol;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name: name2,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isDownloadError(error) {\n        return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            statusCode: this.statusCode,\n            statusText: this.statusText,\n            cause: this.cause\n        };\n    }\n};\n_a2 = symbol2;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a8;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a8 = response.headers.get(\"content-type\")) != null ? _a8 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a3] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidDataContentError(error) {\n        return error instanceof Error && error.name === name3 && error.content != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            cause: this.cause,\n            content: this.content\n        };\n    }\n};\n_a3 = symbol3;\n// core/prompt/data-content.ts\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name4,\n            message\n        });\n        this[_a4] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker4);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n_a4 = symbol4;\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, downloadImplementation = download }) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    const downloadedImages = modelSupportsImageUrls || prompt.messages == null ? null : await downloadImages(prompt.messages, downloadImplementation);\n    const promptType = prompt.type;\n    switch(promptType){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedImages)));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = promptType;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message, downloadedImages) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ]\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>{\n                        var _a8, _b, _c;\n                        switch(part.type){\n                            case \"text\":\n                                {\n                                    return part;\n                                }\n                            case \"image\":\n                                {\n                                    if (part.image instanceof URL) {\n                                        if (downloadedImages == null) {\n                                            return {\n                                                type: \"image\",\n                                                image: part.image,\n                                                mimeType: part.mimeType\n                                            };\n                                        } else {\n                                            const downloadedImage = downloadedImages[part.image.toString()];\n                                            return {\n                                                type: \"image\",\n                                                image: downloadedImage.data,\n                                                mimeType: (_a8 = part.mimeType) != null ? _a8 : downloadedImage.mimeType\n                                            };\n                                        }\n                                    }\n                                    if (typeof part.image === \"string\") {\n                                        try {\n                                            const url = new URL(part.image);\n                                            switch(url.protocol){\n                                                case \"http:\":\n                                                case \"https:\":\n                                                    {\n                                                        if (downloadedImages == null) {\n                                                            return {\n                                                                type: \"image\",\n                                                                image: url,\n                                                                mimeType: part.mimeType\n                                                            };\n                                                        } else {\n                                                            const downloadedImage = downloadedImages[part.image];\n                                                            return {\n                                                                type: \"image\",\n                                                                image: downloadedImage.data,\n                                                                mimeType: (_b = part.mimeType) != null ? _b : downloadedImage.mimeType\n                                                            };\n                                                        }\n                                                    }\n                                                case \"data:\":\n                                                    {\n                                                        try {\n                                                            const [header, base64Content] = part.image.split(\",\");\n                                                            const mimeType = header.split(\";\")[0].split(\":\")[1];\n                                                            if (mimeType == null || base64Content == null) {\n                                                                throw new Error(\"Invalid data URL format\");\n                                                            }\n                                                            return {\n                                                                type: \"image\",\n                                                                image: convertDataContentToUint8Array(base64Content),\n                                                                mimeType\n                                                            };\n                                                        } catch (error) {\n                                                            throw new Error(`Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.getErrorMessage)(message)}`);\n                                                        }\n                                                    }\n                                                default:\n                                                    {\n                                                        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                                                    }\n                                            }\n                                        } catch (_ignored) {}\n                                    }\n                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                    return {\n                                        type: \"image\",\n                                        image: imageUint8,\n                                        mimeType: (_c = part.mimeType) != null ? _c : detectImageMimeType(imageUint8)\n                                    };\n                                }\n                        }\n                    })\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ]\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\")\n                };\n            }\n        case \"tool\":\n            {\n                return message;\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadImages(messages, downloadImplementation) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\").map((part)=>part.image).map((part)=>// support string urls in image parts:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL);\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.messages != null) {\n        for (const message of prompt.messages){\n            if (message.role === \"system\" && typeof message.content !== \"string\") {\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                    prompt,\n                    message: \"system message content must be a string\"\n                });\n            }\n        }\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name: name5,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a5] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidArgumentError(error) {\n        return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            parameter: this.parameter,\n            value: this.value\n        };\n    }\n};\n_a5 = symbol5;\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/types/token-usage.ts\nfunction calculateCompletionTokenUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// core/util/schema.ts\n\n\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, { validate } = {}) {\n    return {\n        [schemaSymbol]: true,\n        _type: void 0,\n        // should never be used directly\n        [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.validatorSymbol]: true,\n        jsonSchema: jsonSchema2,\n        validate\n    };\n}\nfunction isSchema(value) {\n    return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n    return isSchema(schema) ? schema : zodSchema(schema);\n}\nfunction zodSchema(zodSchema2) {\n    return jsonSchema(// we assume that zodToJsonSchema will return a valid JSONSchema7:\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zodSchema2), {\n        validate: (value)=>{\n            const result = zodSchema2.safeParse(value);\n            return result.success ? {\n                success: true,\n                value: result.data\n            } : {\n                success: false,\n                error: result.error\n            };\n        }\n    });\n}\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    return {\n        tools: Object.entries(tools).map(([name8, tool])=>({\n                type: \"function\",\n                name: name8,\n                description: tool.description,\n                parameters: asSchema(tool.parameters).jsonSchema\n            })),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// errors/invalid-tool-arguments-error.ts\n\nvar name6 = \"AI_InvalidToolArgumentsError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(cause)}` }){\n        super({\n            name: name6,\n            message,\n            cause\n        });\n        this[_a6] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker6);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidToolArgumentsError(error) {\n        return error instanceof Error && error.name === name6 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            toolName: this.toolName,\n            toolArgs: this.toolArgs\n        };\n    }\n};\n_a6 = symbol6;\n// errors/no-such-tool-error.ts\n\nvar name7 = \"AI_NoSuchToolError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchToolError(error) {\n        return error instanceof Error && error.name === name7 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            toolName: this.toolName,\n            availableTools: this.availableTools\n        };\n    }\n};\n_a7 = symbol7;\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_9__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a8;\n            await ((_a8 = it.return) == null ? void 0 : _a8.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\nvar STREAM_DATA_WARNING_TIME_MS = 15 * 1e3;\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a8, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a8 = choice.delta) == null ? void 0 : _a8.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a8, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a8 = json.choices[0]) == null ? void 0 : _a8.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// util/consume-stream.ts\nasync function consumeStream(stream) {\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n}\n// rsc/render.ts\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name8, { description, parameters }])=>{\n        return {\n            name: name8,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name8, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name: name8,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a8, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a8 = options.functions) == null ? void 0 : _a8[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a8, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a8 = options.tools) == null ? void 0 : _a8[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n// util/is-async-generator.ts\nfunction isAsyncGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.asyncIterator in value;\n}\n// util/is-generator.ts\nfunction isGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.iterator in value;\n}\n// rsc/stream-ui/stream-ui.tsx\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, initial, text, onFinish, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name8, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name8);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function render2({ args, renderer, streamableUI, isLastCall = false }) {\n        if (!renderer) return;\n        const renderFinished = createResolvablePromise();\n        finished = finished ? finished.then(()=>renderFinished.promise) : renderFinished.promise;\n        const rendererResult = renderer(...args);\n        if (isAsyncGenerator(rendererResult) || isGenerator(rendererResult)) {\n            while(true){\n                const { done, value } = await rendererResult.next();\n                const node = await value;\n                if (isLastCall && done) {\n                    streamableUI.done(node);\n                } else {\n                    streamableUI.update(node);\n                }\n                if (done) break;\n            }\n        } else {\n            const node = await rendererResult;\n            if (isLastCall) {\n                streamableUI.done(node);\n            } else {\n                streamableUI.update(node);\n            }\n        }\n        renderFinished.resolve(void 0);\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(async ()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice\n                })\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n                prompt: validatedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            abortSignal,\n            headers\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            render2({\n                                renderer: textRender,\n                                args: [\n                                    {\n                                        content,\n                                        done: false,\n                                        delta: value.textDelta\n                                    }\n                                ],\n                                streamableUI: ui\n                            });\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            hasToolCall = true;\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_8__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            render2({\n                                renderer: tool.generate,\n                                args: [\n                                    parseResult.value,\n                                    {\n                                        toolName,\n                                        toolCallId: value.toolCallId\n                                    }\n                                ],\n                                streamableUI: ui,\n                                isLastCall: true\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {\n                            onFinish == null ? void 0 : onFinish({\n                                finishReason: value.finishReason,\n                                usage: calculateCompletionTokenUsage(value.usage),\n                                value: ui.value,\n                                warnings: result.warnings,\n                                rawResponse: result.rawResponse\n                            });\n                        }\n                }\n            }\n            if (!hasToolCall) {\n                render2({\n                    renderer: textRender,\n                    args: [\n                        {\n                            content,\n                            done: true\n                        }\n                    ],\n                    streamableUI: ui,\n                    isLastCall: true\n                });\n            }\n            await finished;\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"45e4555d644c409f5a3230e473941a60df6485a1\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name8 in actions){\n        wrappedActions[name8] = wrapAction(actions[name8], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a8, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_4__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a8 = props.initialUIState) != null ? _a8 : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_11__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9haS9yc2MvZGlzdC9yc2Mtc2VydmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDRzs7QUNRM0IsU0FBU0U7SUFLZCxJQUFJQztJQUNKLElBQUlDO0lBRUosTUFBTUMsVUFBVSxJQUFJQyxRQUFXLENBQUNDLEtBQUtDO1FBQ25DTCxVQUFVSTtRQUNWSCxTQUFTSTtJQUNYO0lBRUEsT0FBTztRQUNMSDtRQUNBRjtRQUNBQztJQUNGO0FBQ0Y7O0FDckJPLElBQU1LLGFBQWEsQ0FBQ0MsUUFDekIsT0FBT0EsVUFBVTs7QUZPbkIsSUFBTUMsc0JBQXNCLElBQUlWLDBEQUFpQkE7QUFTakQsU0FBU1csdUJBQXVCQyxPQUFBO0lBQzlCLE1BQU1DLFFBQVFILG9CQUFvQkksUUFBQTtJQUNsQyxJQUFJLENBQUNELE9BQU87UUFDVixNQUFNLElBQUlFLE1BQU1IO0lBQ2xCO0lBQ0EsT0FBT0M7QUFDVDtBQUVPLFNBQVNHLFlBQ2QsRUFBRUMsT0FBQUEsTUFBQSxFQUFPQyxPQUFBLEVBQVEsRUFDakJDLEVBQUE7SUFFQSxPQUFPVCxvQkFBb0JVLEdBQUEsQ0FDekI7UUFDRUMsY0FBY0o7UUFDZEssZUFBZUw7UUFDZk0sUUFBUTtRQUNSTDtJQUNGLEdBQ0FDO0FBRUo7QUFFTyxTQUFTSztJQUNkLE1BQU1YLFFBQVFGLHVCQUF1QjtJQUNyQyxPQUFPRSxNQUFNWSxvQkFBQTtBQUNmO0FBS08sU0FBU0M7SUFDZCxNQUFNYixRQUFRRix1QkFBdUI7SUFDckNFLE1BQU1VLE1BQUEsR0FBUztBQUNqQjtBQWdCQSxTQUFTSSxXQUFBLEdBQ0pDLElBQUE7SUFFSCxNQUFNZixRQUFRRix1QkFDWjtJQUdGLElBQUlpQixLQUFLQyxNQUFBLEdBQVMsR0FBRztRQUNuQixNQUFNQyxNQUFNRixJQUFBLENBQUssRUFBQztRQUNsQixJQUFJLE9BQU9mLE1BQU1RLFlBQUEsS0FBaUIsVUFB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OFkscUJBQXFCRixlQUN2Qk4sV0FBV00sY0FBYyxDQUFDLEtBQzFCO0lBRUosTUFBTUcsS0FBNEMsT0FBTUM7UUFoSDFELElBQUFsWixLQUFBQztRQWlISSxJQUFJLHVNQUFjbVksRUFBTztZQUl2QixNQUFNLElBQUkxWixNQUNSO1FBRUo7UUFFQSxJQUFJeWEsVUFBQSxDQUFVblosTUFBQWtaLE1BQU1MLGNBQUEsS0FBTixPQUFBN1ksTUFBd0I2WTtRQUN0QyxJQUFJTyxVQUFBLENBQVVuWixLQUFBaVosTUFBTU4sY0FBQSxLQUFOLE9BQUEzWSxLQUF3QjJZO1FBQ3RDLElBQUlTLGVBQWU7UUFFbkIsSUFBSUwsb0JBQW9CO1lBQ3RCLE1BQU0sQ0FBQ00saUJBQWlCQyxXQUFVLEdBQUksTUFBTVAsbUJBQW1CSTtZQUMvRCxJQUFJRyxlQUFlLFFBQVc7Z0JBQzVCRixlQUFlQztnQkFDZkgsVUFBVUk7WUFDWjtRQUNGO1FBRUEsT0FDRSxnQkFBQXRZLHNEQUFBQSxDQUFDb1gsZ0VBQWtCQSxFQUFsQjtZQUNDVTtZQUNBQztZQUNBSCxnQkFBZ0JNO1lBQ2hCUCxnQkFBZ0JRO1lBQ2hCSSxxQkFBcUJIO1lBRXBCM1gsVUFBQXdYLE1BQU14WCxRQUFBO1FBQUE7SUFHYjtJQUVBLE9BQU91WDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9haS1zdGF0ZS50c3g/MzgwMCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZS50cz83NTBlIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9pcy1mdW5jdGlvbi50cz8yZDRjIiwid2VicGFjazovL2Fza19kb2MvLi4vY29uc3RhbnRzLnRzP2FiNzIiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi9jcmVhdGUtc3VzcGVuZGVkLWNodW5rLnRzeD84MzM3Iiwid2VicGFjazovL2Fza19kb2MvLi4vc3RyZWFtYWJsZS50c3g/NjkxZiIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uL3JlbmRlci50cz8wZTI0Iiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHM/NGQxOSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvZGVsYXkudHM/MjhhZiIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvcmV0cnktZXJyb3IudHM/ODc1OCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzPzcxNzQiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi91dGlsL2Rvd25sb2FkLWVycm9yLnRzPzZhNzUiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi91dGlsL2Rvd25sb2FkLnRzPzY3YWMiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9jb3JlL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlLnRzPzk1NDUiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9jb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHM/ZTkyZiIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvcHJvbXB0L2ludmFsaWQtZGF0YS1jb250ZW50LWVycm9yLnRzP2YyZmUiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9jb3JlL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50cz84OTcwIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQudHM/NTc4ZSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzP2Y0MjEiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHM/ZDU4YyIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvdHlwZXMvdG9rZW4tdXNhZ2UudHM/OWFmNCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvdXRpbC9zY2hlbWEudHM/Mzc3ZCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2NvcmUvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzP2NhYzgiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50cz8xOGEwIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vZXJyb3JzL2ludmFsaWQtdG9vbC1hcmd1bWVudHMtZXJyb3IudHM/OTY5MCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL2Vycm9ycy9uby1zdWNoLXRvb2wtZXJyb3IudHM/NzkwYiIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3N0cmVhbXMvYWktc3RyZWFtLnRzPzQ4NTQiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9zdHJlYW1zL3N0cmVhbS1kYXRhLnRzPzY3MzAiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi9zdHJlYW1zL29wZW5haS1zdHJlYW0udHM/YjJiZCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uLy4uL3V0aWwvY29uc3VtZS1zdHJlYW0udHM/NzMwOCIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uL3N0cmVhbS11aS9zdHJlYW0tdWkudHN4PzFjY2EiLCJ3ZWJwYWNrOi8vYXNrX2RvYy8uLi8uLi91dGlsL2lzLWFzeW5jLWdlbmVyYXRvci50cz9kOTYwIiwid2VicGFjazovL2Fza19kb2MvLi4vLi4vdXRpbC9pcy1nZW5lcmF0b3IudHM/ZGZkNSIsIndlYnBhY2s6Ly9hc2tfZG9jLy4uL3Byb3ZpZGVyLnRzeD8zMGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXMtZnVuY3Rpb24nO1xuaW1wb3J0IHR5cGUge1xuICBBSVByb3ZpZGVyLFxuICBJbmZlckFJU3RhdGUsXG4gIEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuICBNdXRhYmxlQUlTdGF0ZSxcbiAgVmFsdWVPclVwZGF0ZXIsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBJdCBpcyBwb3NzaWJsZSB0aGF0IG11bHRpcGxlIEFJIHJlcXVlc3RzIGdldCBpbiBjb25jdXJyZW50bHksIGZvciBkaWZmZXJlbnRcbi8vIEFJIGluc3RhbmNlcy4gU28gQUxTIGlzIG5lY2Vzc2FyeSBoZXJlIGZvciBhIHNpbXBsZXIgQVBJLlxuY29uc3QgYXN5bmNBSVN0YXRlU3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZTx7XG4gIGN1cnJlbnRTdGF0ZTogYW55O1xuICBvcmlnaW5hbFN0YXRlOiBhbnk7XG4gIHNlYWxlZDogYm9vbGVhbjtcbiAgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnM7XG4gIG11dGF0aW9uRGVsdGFQcm9taXNlPzogUHJvbWlzZTxhbnk+O1xuICBtdXRhdGlvbkRlbHRhUmVzb2x2ZT86ICh2OiBhbnkpID0+IHZvaWQ7XG59PigpO1xuXG5mdW5jdGlvbiBnZXRBSVN0YXRlU3RvcmVPclRocm93KG1lc3NhZ2U6IHN0cmluZykge1xuICBjb25zdCBzdG9yZSA9IGFzeW5jQUlTdGF0ZVN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQUlTdGF0ZTxTLCBUPihcbiAgeyBzdGF0ZSwgb3B0aW9ucyB9OiB7IHN0YXRlOiBTOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBmbjogKCkgPT4gVCxcbik6IFQge1xuICByZXR1cm4gYXN5bmNBSVN0YXRlU3RvcmFnZS5ydW4oXG4gICAge1xuICAgICAgY3VycmVudFN0YXRlOiBzdGF0ZSxcbiAgICAgIG9yaWdpbmFsU3RhdGU6IHN0YXRlLFxuICAgICAgc2VhbGVkOiBmYWxzZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgfSxcbiAgICBmbixcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFJU3RhdGVEZWx0YVByb21pc2UoKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdygnSW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuJyk7XG4gIHJldHVybiBzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZTtcbn1cblxuLy8gSW50ZXJuYWwgbWV0aG9kLiBUaGlzIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBBSSBBY3Rpb24gaGFzIGJlZW4gcmV0dXJuZWRcbi8vIGFuZCB5b3UgY2FuIG5vIGxvbmdlciBjYWxsIGBnZXRNdXRhYmxlQUlTdGF0ZSgpYCBpbnNpZGUgYW55IGFzeW5jIGNhbGxiYWNrc1xuLy8gY3JlYXRlZCBieSB0aGF0IEFjdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBzZWFsTXV0YWJsZUFJU3RhdGUoKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdygnSW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuJyk7XG4gIHN0b3JlLnNlYWxlZCA9IHRydWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IEFJIHN0YXRlLlxuICogSWYgYGtleWAgaXMgcHJvdmlkZWQsIGl0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGtleSBpbiB0aGVcbiAqIEFJIHN0YXRlLCBpZiBpdCdzIGFuIG9iamVjdC4gSWYgaXQncyBub3QgYW4gb2JqZWN0LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuICpcbiAqIEBleGFtcGxlIGNvbnN0IHN0YXRlID0gZ2V0QUlTdGF0ZSgpIC8vIEdldCB0aGUgZW50aXJlIEFJIHN0YXRlXG4gKiBAZXhhbXBsZSBjb25zdCBmaWVsZCA9IGdldEFJU3RhdGUoJ2tleScpIC8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGtleVxuICovXG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogUmVhZG9ubHk8XG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PlxuPjtcbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBSZWFkb25seTxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+O1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXG4gICAgJ2BnZXRBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLicsXG4gICk7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgKX1cIiBmaWVsZCBmcm9tIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXkgYXMga2V5b2YgdHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZV07XG4gIH1cblxuICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbXV0YWJsZSBBSSBzdGF0ZS4gTm90ZSB0aGF0IHlvdSBtdXN0IGNhbGwgYC5kb25lKClgIHdoZW4gZmluaXNoaW5nXG4gKiB1cGRhdGluZyB0aGUgQUkgc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gKiBzdGF0ZS51cGRhdGUoeyAuLi5zdGF0ZS5nZXQoKSwga2V5OiAndmFsdWUnIH0pXG4gKiBzdGF0ZS51cGRhdGUoKGN1cnJlbnRTdGF0ZSkgPT4gKHsgLi4uY3VycmVudFN0YXRlLCBrZXk6ICd2YWx1ZScgfSkpXG4gKiBzdGF0ZS5kb25lKClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICogc3RhdGUuZG9uZSh7IC4uLnN0YXRlLmdldCgpLCBrZXk6ICd2YWx1ZScgfSkgLy8gRG9uZSB3aXRoIGEgbmV3IHN0YXRlXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBNdXRhYmxlQUlTdGF0ZTxcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XG4+O1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBNdXRhYmxlQUlTdGF0ZTxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+O1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgdHlwZSBBSVN0YXRlID0gSW5mZXJBSVN0YXRlPEFJLCBhbnk+O1xuICB0eXBlIEFJU3RhdGVXaXRoS2V5ID0gdHlwZW9mIGFyZ3MgZXh0ZW5kcyBba2V5OiBrZXlvZiBBSVN0YXRlXVxuICAgID8gQUlTdGF0ZVsodHlwZW9mIGFyZ3MpWzBdXVxuICAgIDogQUlTdGF0ZTtcbiAgdHlwZSBOZXdTdGF0ZU9yVXBkYXRlciA9IFZhbHVlT3JVcGRhdGVyPEFJU3RhdGVXaXRoS2V5PjtcblxuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXG4gICAgJ2BnZXRNdXRhYmxlQUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIEFJIEFjdGlvbi4nLFxuICApO1xuXG4gIGlmIChzdG9yZS5zZWFsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBnZXRNdXRhYmxlQUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHJldHVybmluZyBmcm9tIGFuIEFJIEFjdGlvbi4gUGxlYXNlIG1vdmUgaXQgdG8gdGhlIHRvcCBsZXZlbCBvZiB0aGUgQWN0aW9uJ3MgZnVuY3Rpb24gYm9keS5cIixcbiAgICApO1xuICB9XG5cbiAgaWYgKCFzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZSkge1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZSA9IHByb21pc2U7XG4gICAgc3RvcmUubXV0YXRpb25EZWx0YVJlc29sdmUgPSByZXNvbHZlO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9VcGRhdGUobmV3U3RhdGU6IE5ld1N0YXRlT3JVcGRhdGVyLCBkb25lOiBib29sZWFuKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IGNhbid0IG1vZGlmeSB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICApfVwiIGZpZWxkIG9mIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0gPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGUoc3RvcmUuY3VycmVudFN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0gPSBuZXdTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0b3JlLm9wdGlvbnMub25TZXRBSVN0YXRlPy4oe1xuICAgICAga2V5OiBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzWzBdIDogdW5kZWZpbmVkLFxuICAgICAgc3RhdGU6IHN0b3JlLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGRvbmUsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBtdXRhYmxlU3RhdGUgPSB7XG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleV0gYXMgUmVhZG9ubHk8QUlTdGF0ZVdpdGhLZXk+O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlIGFzIFJlYWRvbmx5PEFJU3RhdGU+O1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUobmV3QUlTdGF0ZTogTmV3U3RhdGVPclVwZGF0ZXIpIHtcbiAgICAgIGRvVXBkYXRlKG5ld0FJU3RhdGUsIGZhbHNlKTtcbiAgICB9LFxuICAgIGRvbmU6IGZ1bmN0aW9uIGRvbmUoLi4uZG9uZUFyZ3M6IFtdIHwgW05ld1N0YXRlT3JVcGRhdGVyXSkge1xuICAgICAgaWYgKGRvbmVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZG9VcGRhdGUoZG9uZUFyZ3NbMF0gYXMgTmV3U3RhdGVPclVwZGF0ZXIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWx0YSA9IGpzb25kaWZmcGF0Y2guZGlmZihzdG9yZS5vcmlnaW5hbFN0YXRlLCBzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgc3RvcmUubXV0YXRpb25EZWx0YVJlc29sdmUhKGRlbHRhKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBtdXRhYmxlU3RhdGU7XG59XG5cbmV4cG9ydCB7IGdldEFJU3RhdGUsIGdldE11dGFibGVBSVN0YXRlIH07XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBQcm9taXNlIHdpdGggZXh0ZXJuYWxseSBhY2Nlc3NpYmxlIHJlc29sdmUgYW5kIHJlamVjdCBmdW5jdGlvbnMuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdGhhdCB0aGUgUHJvbWlzZSB3aWxsIHJlc29sdmUgdG8uXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZzpcbiAqICAgLSBwcm9taXNlOiBBIFByb21pc2UgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgZXh0ZXJuYWxseS5cbiAqICAgLSByZXNvbHZlOiBBIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIFByb21pc2Ugd2l0aCBhIHZhbHVlIG9mIHR5cGUgVC5cbiAqICAgLSByZWplY3Q6IEEgZnVuY3Rpb24gdG8gcmVqZWN0IHRoZSBQcm9taXNlIHdpdGggYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxUID0gYW55PigpOiB7XG4gIHByb21pc2U6IFByb21pc2U8VD47XG4gIHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZDtcbiAgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG59IHtcbiAgbGV0IHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZDtcbiAgbGV0IHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkO1xuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmU6IHJlc29sdmUhLFxuICAgIHJlamVjdDogcmVqZWN0ISxcbiAgfTtcbn1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiIsImV4cG9ydCBjb25zdCBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgPSBTeW1ib2wuZm9yKCd1aS5zdHJlYW1hYmxlLnZhbHVlJyk7XG5leHBvcnQgY29uc3QgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUgPSAxNSAqIDEwMDA7XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5cbi8vIFJlY3Vyc2l2ZSB0eXBlIGZvciB0aGUgY2h1bmsuXG50eXBlIENodW5rVHlwZSA9XG4gIHwge1xuICAgICAgZG9uZTogZmFsc2U7XG4gICAgICB2YWx1ZTogUmVhY3QuUmVhY3ROb2RlO1xuICAgICAgbmV4dDogUHJvbWlzZTxDaHVua1R5cGU+O1xuICAgICAgYXBwZW5kPzogYm9vbGVhbjtcbiAgICB9XG4gIHwge1xuICAgICAgZG9uZTogdHJ1ZTtcbiAgICAgIHZhbHVlOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgfTtcblxuLy8gVXNlIHNpbmdsZSBsZXR0ZXIgbmFtZXMgZm9yIHRoZSB2YXJpYWJsZXMgdG8gcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBSU0MgcGF5bG9hZC5cbi8vIGBSYCBmb3IgYFJvd2AsIGBjYCBmb3IgYGN1cnJlbnRgLCBgbmAgZm9yIGBuZXh0YC5cbi8vIE5vdGU6IEFycmF5IGNvbnN0cnVjdGlvbiBpcyBuZWVkZWQgdG8gYWNjZXNzIHRoZSBuYW1lIFIuXG5jb25zdCBSID0gW1xuICAoYXN5bmMgKHtcbiAgICBjOiBjdXJyZW50LFxuICAgIG46IG5leHQsXG4gIH06IHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxDaHVua1R5cGU+O1xuICB9KSA9PiB7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBuZXh0O1xuXG4gICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsuYXBwZW5kKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIHtjdXJyZW50fVxuICAgICAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICAgICAgPC9TdXNwZW5zZT5cbiAgICAgICAgPC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICk7XG4gIH0pIGFzIHVua25vd24gYXMgUmVhY3QuRkM8e1xuICAgIGM6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBuOiBQcm9taXNlPENodW5rVHlwZT47XG4gIH0+LFxuXVswXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3VzcGVuZGVkIGNodW5rIGZvciBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBhIHN1c3BlbnNlZnVsIFJlYWN0IGNvbXBvbmVudCB0aGF0IGNhbiBiZSBkeW5hbWljYWxseSB1cGRhdGVkLlxuICogSXQncyB1c2VmdWwgZm9yIHN0cmVhbWluZyB1cGRhdGVzIHRvIHRoZSBjbGllbnQgaW4gYSBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuUmVhY3ROb2RlfSBpbml0aWFsVmFsdWUgLSBUaGUgaW5pdGlhbCB2YWx1ZSB0byByZW5kZXIgd2hpbGUgdGhlIHByb21pc2UgaXMgcGVuZGluZy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nOlxuICogICAtIHJvdzogQSBSZWFjdCBub2RlIHRoYXQgcmVuZGVycyB0aGUgc3VzcGVuc2VmdWwgY29udGVudC5cbiAqICAgLSByZXNvbHZlOiBBIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCBhIG5ldyB2YWx1ZS5cbiAqICAgLSByZWplY3Q6IEEgZnVuY3Rpb24gdG8gcmVqZWN0IHRoZSBwcm9taXNlIHdpdGggYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdXNwZW5kZWRDaHVuayhpbml0aWFsVmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IHtcbiAgcm93OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJlc29sdmU6ICh2YWx1ZTogQ2h1bmtUeXBlKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbn0ge1xuICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8Q2h1bmtUeXBlPigpO1xuXG4gIHJldHVybiB7XG4gICAgcm93OiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2luaXRpYWxWYWx1ZX0+XG4gICAgICAgIDxSIGM9e2luaXRpYWxWYWx1ZX0gbj17cHJvbWlzZX0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7XG4gIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FLFxuICBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNyZWF0ZVN1c3BlbmRlZENodW5rIH0gZnJvbSAnLi9jcmVhdGUtc3VzcGVuZGVkLWNodW5rJztcbmltcG9ydCB0eXBlIHsgU3RyZWFtYWJsZVBhdGNoLCBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3R5cGVzJztcblxuLy8gSXQncyBuZWNlc3NhcnkgdG8gZGVmaW5lIHRoZSB0eXBlIG1hbnVhbGx5IGhlcmUsIG90aGVyd2lzZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4vLyB3aWxsIG5vdCBiZSBhYmxlIHRvIGluZmVyIHRoZSBjb3JyZWN0IHJldHVybiB0eXBlIGFzIGl0J3MgY2lyY3VsYXIuXG50eXBlIFN0cmVhbWFibGVVSVdyYXBwZXIgPSB7XG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgVUkuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZCByZWNlaXZlZCBieSB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBVSSBub2RlLiBJdCB0YWtlcyBhIG5ldyBVSSBub2RlIGFuZCByZXBsYWNlcyB0aGUgb2xkIG9uZS5cbiAgICovXG4gIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKTogU3RyZWFtYWJsZVVJV3JhcHBlcjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBuZXcgVUkgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBvbGQgb25lLlxuICAgKiBPbmNlIGFwcGVuZGVkIGEgbmV3IFVJIG5vZGUsIHRoZSBwcmV2aW91cyBVSSBub2RlIGNhbm5vdCBiZSB1cGRhdGVkIGFueW1vcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSSg8ZGl2PmhlbGxvPC9kaXY+KVxuICAgKiB1aS5hcHBlbmQoPGRpdj53b3JsZDwvZGl2PilcbiAgICpcbiAgICogLy8gVGhlIFVJIG5vZGUgd2lsbCBiZTpcbiAgICogLy8gPD5cbiAgICogLy8gICA8ZGl2PmhlbGxvPC9kaXY+XG4gICAqIC8vICAgPGRpdj53b3JsZDwvZGl2PlxuICAgKiAvLyA8Lz5cbiAgICogYGBgXG4gICAqL1xuICBhcHBlbmQodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIFVJIHN0cmVhbS5cbiAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIGFuZCBjYXVnaHQgYnkgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgY29tcG9uZW50LlxuICAgKi9cbiAgZXJyb3IoZXJyb3I6IGFueSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSBVSSBub2RlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0IGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgVUkgbm9kZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAqIE9uY2UgY2FsbGVkLCB0aGUgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZSB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICovXG4gIGRvbmUoLi4uYXJnczogW1JlYWN0LlJlYWN0Tm9kZV0gfCBbXSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHBpZWNlIG9mIGNoYW5nZWFibGUgVUkgdGhhdCBjYW4gYmUgc3RyZWFtZWQgdG8gdGhlIGNsaWVudC5cbiAqIE9uIHRoZSBjbGllbnQgc2lkZSwgaXQgY2FuIGJlIHJlbmRlcmVkIGFzIGEgbm9ybWFsIFJlYWN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsVmFsdWU/OiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgeyByb3csIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlU3VzcGVuZGVkQ2h1bmsoaW5pdGlhbFZhbHVlKTtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVUkgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGNvbnN0IHN0cmVhbWFibGU6IFN0cmVhbWFibGVVSVdyYXBwZXIgPSB7XG4gICAgdmFsdWU6IHJvdyxcbiAgICB1cGRhdGUodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0J3MgcmVmZXJlbnRpYWxseSBlcXVhbC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBjdXJyZW50VmFsdWUsIGRvbmU6IGZhbHNlLCBuZXh0OiByZXNvbHZhYmxlLnByb21pc2UgfSk7XG4gICAgICByZXNvbHZlID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVqZWN0ID0gcmVzb2x2YWJsZS5yZWplY3Q7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGFwcGVuZCh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5hcHBlbmQoKScpO1xuXG4gICAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICByZXNvbHZlKHsgdmFsdWUsIGRvbmU6IGZhbHNlLCBhcHBlbmQ6IHRydWUsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZXJyb3IoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICByZWplY3QoZXJyb3IpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGRvbmUoLi4uYXJnczogW10gfCBbUmVhY3QuUmVhY3ROb2RlXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IGFyZ3NbMF0sIGRvbmU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBjdXJyZW50VmFsdWUsIGRvbmU6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHN0cmVhbWFibGU7XG59XG5cbmNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DSyA9IFN5bWJvbCgnc3RyZWFtYWJsZS52YWx1ZS5sb2NrJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgd3JhcHBlZCwgY2hhbmdlYWJsZSB2YWx1ZSB0aGF0IGNhbiBiZSBzdHJlYW1lZCB0byB0aGUgY2xpZW50LlxuICogT24gdGhlIGNsaWVudCBzaWRlLCB0aGUgdmFsdWUgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgcmVhZFN0cmVhbWFibGVWYWx1ZSgpIEFQSS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVZhbHVlPFQgPSBhbnksIEUgPSBhbnk+KFxuICBpbml0aWFsVmFsdWU/OiBUIHwgUmVhZGFibGVTdHJlYW08VD4sXG4pIHtcbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9XG4gICAgaW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHxcbiAgICAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGluaXRpYWxWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgJ2dldFJlYWRlcicgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgJ2xvY2tlZCcgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmxvY2tlZCA9PT0gJ2Jvb2xlYW4nKTtcblxuICBpZiAoIWlzUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPihpbml0aWFsVmFsdWUpO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPigpO1xuXG4gIC8vIFNpbmNlIHRoZSBzdHJlYW1hYmxlIHZhbHVlIHdpbGwgYmUgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSwgaXQncyBub3QgYWxsb3dlZFxuICAvLyB0byB1cGRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5IGFzIHRoYXQgaW50cm9kdWNlcyByYWNlIGNvbmRpdGlvbnMgYW5kXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gIC8vIFdlIGxvY2sgdGhlIHZhbHVlIHRvIHByZXZlbnQgYW55IHVwZGF0ZXMgZnJvbSB0aGUgdXNlci5cbiAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuXG4gIChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnN1bWUgdGhlIHJlYWRhYmxlIHN0cmVhbSBhbmQgdXBkYXRlIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IHJlYWRlciA9IGluaXRpYWxWYWx1ZS5nZXRSZWFkZXIoKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVubG9jayB0aGUgdmFsdWUgdG8gYWxsb3cgdXBkYXRlcy5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2NrIHRoZSB2YWx1ZSBhZ2Fpbi5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmRvbmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmVycm9yKGUpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gc3RyZWFtYWJsZVZhbHVlO1xufVxuXG4vLyBJdCdzIG5lY2Vzc2FyeSB0byBkZWZpbmUgdGhlIHR5cGUgbWFudWFsbHkgaGVyZSwgb3RoZXJ3aXNlIFR5cGVTY3JpcHQgY29tcGlsZXJcbi8vIHdpbGwgbm90IGJlIGFibGUgdG8gaW5mZXIgdGhlIGNvcnJlY3QgcmV0dXJuIHR5cGUgYXMgaXQncyBjaXJjdWxhci5cbnR5cGUgU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPiA9IHtcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZS4gVGhpcyBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFNlcnZlciBBY3Rpb24gYW5kXG4gICAqIHJlY2VpdmVkIGJ5IHRoZSBjbGllbnQuIFRvIHJlYWQgdGhlIHN0cmVhbWVkIHZhbHVlcywgdXNlIHRoZVxuICAgKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAgQVBJcy5cbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBTdHJlYW1hYmxlVmFsdWU8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgdmFsdWUgd2l0aCBhIG5ldyBvbmUuXG4gICAqL1xuICB1cGRhdGUodmFsdWU6IFQpOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGFwcGVuZCBhIGRlbHRhIHN0cmluZyB0byB0aGUgY3VycmVudCB2YWx1ZS4gSXRcbiAgICogcmVxdWlyZXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgdG8gYmUgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCBzdHJlYW1hYmxlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCdoZWxsbycpO1xuICAgKiBzdHJlYW1hYmxlLmFwcGVuZCgnIHdvcmxkJyk7XG4gICAqXG4gICAqIC8vIFRoZSB2YWx1ZSB3aWxsIGJlICdoZWxsbyB3b3JsZCdcbiAgICogYGBgXG4gICAqL1xuICBhcHBlbmQodmFsdWU6IFQpOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSB2YWx1ZSBzdHJlYW0uXG4gICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSB3aGVuIGNvbnN1bWVkIHZpYVxuICAgKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAuXG4gICAqL1xuICBlcnJvcihlcnJvcjogYW55KTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbWFya3MgdGhlIHZhbHVlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0XG4gICAqIGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgdmFsdWUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgKiBPbmNlIGNhbGxlZCwgdGhlIHZhbHVlIGNhbm5vdCBiZSB1cGRhdGVkIG9yIGFwcGVuZGVkIGFueW1vcmUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFsd2F5cyAqKnJlcXVpcmVkKiogdG8gYmUgY2FsbGVkLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlXG4gICAqIHdpbGwgYmUgc3R1Y2sgaW4gYSBsb2FkaW5nIHN0YXRlLlxuICAgKi9cbiAgZG9uZSguLi5hcmdzOiBbVF0gfCBbXSk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBUaGlzIGlzIGFuIGludGVybmFsIGxvY2sgdG8gcHJldmVudCB0aGUgdmFsdWUgZnJvbSBiZWluZ1xuICAgKiB1cGRhdGVkIGJ5IHRoZSB1c2VyLlxuICAgKi9cbiAgW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS106IGJvb2xlYW47XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQgPSBhbnksIEUgPSBhbnk+KGluaXRpYWxWYWx1ZT86IFQpIHtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgbG9ja2VkID0gZmFsc2U7XG4gIGxldCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PigpO1xuXG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjdXJyZW50RXJyb3I6IEUgfCB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50UHJvbWlzZTogdHlwZW9mIHJlc29sdmFibGUucHJvbWlzZSB8IHVuZGVmaW5lZCA9XG4gICAgcmVzb2x2YWJsZS5wcm9taXNlO1xuICBsZXQgY3VycmVudFBhdGNoVmFsdWU6IFN0cmVhbWFibGVQYXRjaDtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIG1ldGhvZCArICc6IFZhbHVlIHN0cmVhbSBpcyBsb2NrZWQgYW5kIGNhbm5vdCBiZSB1cGRhdGVkLicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSB2YWx1ZSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWQoaW5pdGlhbENodW5rPzogYm9vbGVhbik6IFN0cmVhbWFibGVWYWx1ZTxULCBFPiB7XG4gICAgLy8gVGhpcyBtYWtlcyB0aGUgcGF5bG9hZCBtdWNoIHNtYWxsZXIgaWYgdGhlcmUncmUgbXV0YXRpdmUgdXBkYXRlcyBiZWZvcmUgdGhlIGZpcnN0IHJlYWQuXG4gICAgbGV0IGluaXQ6IFBhcnRpYWw8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAgIGlmIChjdXJyZW50RXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdCA9IHsgZXJyb3I6IGN1cnJlbnRFcnJvciB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFBhdGNoVmFsdWUgJiYgIWluaXRpYWxDaHVuaykge1xuICAgICAgICBpbml0ID0geyBkaWZmOiBjdXJyZW50UGF0Y2hWYWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdCA9IHsgY3VycjogY3VycmVudFZhbHVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICBpbml0Lm5leHQgPSBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbENodW5rKSB7XG4gICAgICBpbml0LnR5cGUgPSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGBjdXJyZW50VmFsdWVgIGFuZCBgY3VycmVudFBhdGNoVmFsdWVgIGlmIG5lZWRlZC5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWVTdGF0ZXModmFsdWU6IFQpIHtcbiAgICAvLyBJZiB3ZSBjYW4gb25seSBzZW5kIGEgcGF0Y2ggb3ZlciB0aGUgd2lyZSwgaXQncyBiZXR0ZXIgdG8gZG8gc28uXG4gICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMCwgdmFsdWUuc2xpY2UoY3VycmVudFZhbHVlLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+ID0ge1xuICAgIHNldCBbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXShzdGF0ZTogYm9vbGVhbikge1xuICAgICAgbG9ja2VkID0gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlZCh0cnVlKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKHZhbHVlKTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGFwcGVuZCh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuYXBwZW5kKCknKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgY3VycmVudCB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiBjdXJyZW50VmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLiBSZWNlaXZlZDogJHt0eXBlb2YgdmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZV07XG4gICAgICAgIChjdXJyZW50VmFsdWUgYXMgc3RyaW5nKSA9IGN1cnJlbnRWYWx1ZSArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyhjcmVhdGVXcmFwcGVkKCkpO1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBlcnJvcihlcnJvcjogYW55KSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5lcnJvcigpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRFcnJvciA9IGVycm9yO1xuICAgICAgY3VycmVudFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7IGVycm9yIH0pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGRvbmUoLi4uYXJnczogW10gfCBbVF0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKGFyZ3NbMF0pO1xuICAgICAgICByZXNvbHZhYmxlLnJlc29sdmUoY3JlYXRlV3JhcHBlZCgpKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7fSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHN0cmVhbWFibGU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSwgY3JlYXRlU3RyZWFtYWJsZVZhbHVlIH07XG4iLCJpbXBvcnQgdHlwZSBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gJ3pvZC10by1qc29uLXNjaGVtYSc7XG5pbXBvcnQgeyBPcGVuQUlTdHJlYW0gfSBmcm9tICcuLi9zdHJlYW1zJztcbmltcG9ydCB7IGNvbnN1bWVTdHJlYW0gfSBmcm9tICcuLi91dGlsL2NvbnN1bWUtc3RyZWFtJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSB9IGZyb20gJy4vc3RyZWFtYWJsZSc7XG5cbnR5cGUgU3RyZWFtYWJsZSA9IFJlYWN0Tm9kZSB8IFByb21pc2U8UmVhY3ROb2RlPjtcbnR5cGUgUmVuZGVyZXI8VD4gPSAoXG4gIHByb3BzOiBULFxuKSA9PlxuICB8IFN0cmVhbWFibGVcbiAgfCBHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD5cbiAgfCBBc3luY0dlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPjtcblxuLyoqXG4gKiBgcmVuZGVyYCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdHJlYW1hYmxlIFVJIGZyb20gc29tZSBMTE1zLlxuICogVGhpcyBBUEkgb25seSBzdXBwb3J0cyBPcGVuQUkncyBHUFQgbW9kZWxzIHdpdGggRnVuY3Rpb24gQ2FsbGluZyBhbmQgQXNzaXN0YW50cyBUb29scyxcbiAqIHBsZWFzZSB1c2UgYHN0cmVhbVVJYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIHByb3ZpZGVycy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgYHN0cmVhbVVJYCBBUEkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBSSBTREsgQ29yZSBBUElzXG4gKiBhbmQgZnV0dXJlIGZlYXR1cmVzLiBUaGlzIEFQSSB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcjxcbiAgVFMgZXh0ZW5kcyB7XG4gICAgW25hbWU6IHN0cmluZ106IHouU2NoZW1hO1xuICB9ID0ge30sXG4gIEZTIGV4dGVuZHMge1xuICAgIFtuYW1lOiBzdHJpbmddOiB6LlNjaGVtYTtcbiAgfSA9IHt9LFxuPihvcHRpb25zOiB7XG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgbmFtZSB0byB1c2UuIE11c3QgYmUgT3BlbkFJIFNESyBjb21wYXRpYmxlLiBUb29scyBhbmQgRnVuY3Rpb25zIGFyZSBvbmx5IHN1cHBvcnRlZFxuICAgKiBHUFQgbW9kZWxzICgzLjUvNCksIE9wZW5BSSBBc3Npc3RhbnRzLCBNaXN0cmFsIHNtYWxsIGFuZCBsYXJnZSwgYW5kIEZpcmV3b3JrcyBmaXJlZnVuY3Rpb24tdjEuXG4gICAqXG4gICAqIEBleGFtcGxlIFwiZ3B0LTMuNS10dXJib1wiXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHByb3ZpZGVyIGluc3RhbmNlIHRvIHVzZS4gQ3VycmVudGx5IHRoZSBvbmx5IHByb3ZpZGVyIGF2YWlsYWJsZSBpcyBPcGVuQUkuXG4gICAqIFRoaXMgbmVlZHMgdG8gbWF0Y2ggdGhlIG1vZGVsIG5hbWUuXG4gICAqL1xuICBwcm92aWRlcjogT3BlbkFJO1xuICBtZXNzYWdlczogUGFyYW1ldGVyczxcbiAgICB0eXBlb2YgT3BlbkFJLnByb3RvdHlwZS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZVxuICA+WzBdWydtZXNzYWdlcyddO1xuICB0ZXh0PzogUmVuZGVyZXI8e1xuICAgIC8qKlxuICAgICAqIFRoZSBmdWxsIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzbyBmYXIuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgYXBwZW5kZWQgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNpbmNlIHRoZSBsYXN0IGB0ZXh0YCBjYWxsLlxuICAgICAqL1xuICAgIGRlbHRhOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbW9kZWwgaXMgZG9uZSBnZW5lcmF0aW5nIHRleHQuXG4gICAgICogSWYgYHRydWVgLCB0aGUgYGNvbnRlbnRgIHdpbGwgYmUgdGhlIGZpbmFsIG91dHB1dCBhbmQgdGhpcyBjYWxsIHdpbGwgYmUgdGhlIGxhc3QuXG4gICAgICovXG4gICAgZG9uZTogYm9vbGVhbjtcbiAgfT47XG4gIHRvb2xzPzoge1xuICAgIFtuYW1lIGluIGtleW9mIFRTXToge1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICBwYXJhbWV0ZXJzOiBUU1tuYW1lXTtcbiAgICAgIHJlbmRlcjogUmVuZGVyZXI8ei5pbmZlcjxUU1tuYW1lXT4+O1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9ucz86IHtcbiAgICBbbmFtZSBpbiBrZXlvZiBGU106IHtcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgICAgcGFyYW1ldGVyczogRlNbbmFtZV07XG4gICAgICByZW5kZXI6IFJlbmRlcmVyPHouaW5mZXI8RlNbbmFtZV0+PjtcbiAgICB9O1xuICB9O1xuICBpbml0aWFsPzogUmVhY3ROb2RlO1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbn0pOiBSZWFjdE5vZGUge1xuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShvcHRpb25zLmluaXRpYWwpO1xuXG4gIC8vIFRoZSBkZWZhdWx0IHRleHQgcmVuZGVyZXIganVzdCByZXR1cm5zIHRoZSBjb250ZW50IGFzIHN0cmluZy5cbiAgY29uc3QgdGV4dCA9IG9wdGlvbnMudGV4dFxuICAgID8gb3B0aW9ucy50ZXh0XG4gICAgOiAoeyBjb250ZW50IH06IHsgY29udGVudDogc3RyaW5nIH0pID0+IGNvbnRlbnQ7XG5cbiAgY29uc3QgZnVuY3Rpb25zID0gb3B0aW9ucy5mdW5jdGlvbnNcbiAgICA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZnVuY3Rpb25zKS5tYXAoXG4gICAgICAgIChbbmFtZSwgeyBkZXNjcmlwdGlvbiwgcGFyYW1ldGVycyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEocGFyYW1ldGVycykgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCB0b29scyA9IG9wdGlvbnMudG9vbHNcbiAgICA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudG9vbHMpLm1hcChcbiAgICAgICAgKFtuYW1lLCB7IGRlc2NyaXB0aW9uLCBwYXJhbWV0ZXJzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicgYXMgY29uc3QsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogem9kVG9Kc29uU2NoZW1hKHBhcmFtZXRlcnMpIGFzIFJlY29yZDxcbiAgICAgICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICAgICAgdW5rbm93blxuICAgICAgICAgICAgICA+LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGlmIChmdW5jdGlvbnMgJiYgdG9vbHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW4ndCBoYXZlIGJvdGggZnVuY3Rpb25zIGFuZCB0b29scyBkZWZpbmVkLiBQbGVhc2UgY2hvb3NlIG9uZSBvciB0aGUgb3RoZXIuXCIsXG4gICAgKTtcbiAgfVxuXG4gIGxldCBmaW5pc2hlZDogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoXG4gICAgYXJnczogYW55LFxuICAgIHJlbmRlcmVyOiB1bmRlZmluZWQgfCBSZW5kZXJlcjxhbnk+LFxuICAgIHJlczogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RyZWFtYWJsZVVJPixcbiAgKSB7XG4gICAgaWYgKCFyZW5kZXJlcikgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPHZvaWQ+KCk7XG5cbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIGZpbmlzaGVkID0gZmluaXNoZWQudGhlbigoKSA9PiByZXNvbHZhYmxlLnByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hlZCA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHJlbmRlcmVyKGFyZ3MpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3RoZW4nIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0ICh2YWx1ZSBhcyBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4pO1xuICAgICAgcmVzLnVwZGF0ZShub2RlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB2YWx1ZSAmJlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWVcbiAgICApIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgQXN5bmNHZW5lcmF0b3I8XG4gICAgICAgIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICB2b2lkXG4gICAgICA+O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBHZW5lcmF0b3I8UmVhY3QuUmVhY3ROb2RlLCBSZWFjdC5SZWFjdE5vZGUsIHZvaWQ+O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuICB9XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICBsZXQgaGFzRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuXG4gICAgY29uc3VtZVN0cmVhbShcbiAgICAgIE9wZW5BSVN0cmVhbShcbiAgICAgICAgKGF3YWl0IG9wdGlvbnMucHJvdmlkZXIuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgICAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLnRlbXBlcmF0dXJlLFxuICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLih0b29sc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KSkgYXMgYW55LFxuICAgICAgICB7XG4gICAgICAgICAgLi4uKGZ1bmN0aW9uc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXN5bmMgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGZ1bmN0aW9uQ2FsbFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsUGF5bG9hZC5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZnVuY3Rpb25zPy5bZnVuY3Rpb25DYWxsUGF5bG9hZC5uYW1lIGFzIGFueV1cbiAgICAgICAgICAgICAgICAgICAgICA/LnJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLih0b29sc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXN5bmMgZXhwZXJpbWVudGFsX29uVG9vbENhbGwodG9vbENhbGxQYXlsb2FkOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0Z1bmN0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2UgbWlnaHQgbmVlZCBQcm9taXNlLmFsbCBoZXJlP1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xDYWxsUGF5bG9hZC50b29scykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbC5mdW5jLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xzPy5bdG9vbC5mdW5jLm5hbWUgYXMgYW55XT8ucmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIG9uVGV4dChjaHVuaykge1xuICAgICAgICAgICAgY29udGVudCArPSBjaHVuaztcbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogY2h1bmsgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgb25GaW5hbCgpIHtcbiAgICAgICAgICAgIGlmIChoYXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IHRydWUgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfSkoKTtcblxuICByZXR1cm4gdWkudmFsdWU7XG59XG4iLCJpbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSwgaXNBYm9ydEVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyBkZWxheSB9IGZyb20gJy4vZGVsYXknO1xuaW1wb3J0IHsgUmV0cnlFcnJvciB9IGZyb20gJy4vcmV0cnktZXJyb3InO1xuXG5leHBvcnQgdHlwZSBSZXRyeUZ1bmN0aW9uID0gPE9VVFBVVD4oXG4gIGZuOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+LFxuKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+O1xuXG4vKipcblRoZSBgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmYCBzdHJhdGVneSByZXRyaWVzIGEgZmFpbGVkIEFQSSBjYWxsIHdpdGggYW4gZXhwb25lbnRpYWwgYmFja29mZi5cbllvdSBjYW4gY29uZmlndXJlIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzLCB0aGUgaW5pdGlhbCBkZWxheSwgYW5kIHRoZSBiYWNrb2ZmIGZhY3Rvci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiA9XG4gICh7XG4gICAgbWF4UmV0cmllcyA9IDIsXG4gICAgaW5pdGlhbERlbGF5SW5NcyA9IDIwMDAsXG4gICAgYmFja29mZkZhY3RvciA9IDIsXG4gIH0gPSB7fSk6IFJldHJ5RnVuY3Rpb24gPT5cbiAgYXN5bmMgPE9VVFBVVD4oZjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPikgPT5cbiAgICBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgICAgIG1heFJldHJpZXMsXG4gICAgICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gICAgICBiYWNrb2ZmRmFjdG9yLFxuICAgIH0pO1xuXG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmPE9VVFBVVD4oXG4gIGY6ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4sXG4gIHtcbiAgICBtYXhSZXRyaWVzLFxuICAgIGRlbGF5SW5NcyxcbiAgICBiYWNrb2ZmRmFjdG9yLFxuICB9OiB7IG1heFJldHJpZXM6IG51bWJlcjsgZGVsYXlJbk1zOiBudW1iZXI7IGJhY2tvZmZGYWN0b3I6IG51bWJlciB9LFxuICBlcnJvcnM6IHVua25vd25bXSA9IFtdLFxuKTogUHJvbWlzZTxPVVRQVVQ+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gZG9uJ3QgcmV0cnkgd2hlbiB0aGUgcmVxdWVzdCB3YXMgYWJvcnRlZFxuICAgIH1cblxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gZG9uJ3Qgd3JhcCB0aGUgZXJyb3Igd2hlbiByZXRyaWVzIGFyZSBkaXNhYmxlZFxuICAgIH1cblxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG5cbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiAnbWF4UmV0cmllc0V4Y2VlZGVkJyxcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBBUElDYWxsRXJyb3IuaXNBUElDYWxsRXJyb3IoZXJyb3IpICYmXG4gICAgICBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJlxuICAgICAgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXNcbiAgICApIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gZG9uJ3Qgd3JhcCB0aGUgZXJyb3Igd2hlbiBhIG5vbi1yZXRyeWFibGUgZXJyb3Igb2NjdXJzIG9uIHRoZSBmaXJzdCB0cnlcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogJ2Vycm9yTm90UmV0cnlhYmxlJyxcbiAgICAgIGVycm9yczogbmV3RXJyb3JzLFxuICAgIH0pO1xuICB9XG59XG4iLCJleHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheUluTXMpKTtcbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcblxuY29uc3QgbmFtZSA9ICdBSV9SZXRyeUVycm9yJztcbmNvbnN0IG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG5cbmV4cG9ydCB0eXBlIFJldHJ5RXJyb3JSZWFzb24gPVxuICB8ICdtYXhSZXRyaWVzRXhjZWVkZWQnXG4gIHwgJ2Vycm9yTm90UmV0cnlhYmxlJ1xuICB8ICdhYm9ydCc7XG5cbmV4cG9ydCBjbGFzcyBSZXRyeUVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICAvLyBub3RlOiBwcm9wZXJ0eSBvcmRlciBkZXRlcm1pbmVzIGRlYnVnZ2luZyBvdXRwdXRcbiAgcmVhZG9ubHkgcmVhc29uOiBSZXRyeUVycm9yUmVhc29uO1xuICByZWFkb25seSBsYXN0RXJyb3I6IHVua25vd247XG4gIHJlYWRvbmx5IGVycm9yczogQXJyYXk8dW5rbm93bj47XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgcmVhc29uLFxuICAgIGVycm9ycyxcbiAgfToge1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICByZWFzb246IFJldHJ5RXJyb3JSZWFzb247XG4gICAgZXJyb3JzOiBBcnJheTx1bmtub3duPjtcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSB9KTtcblxuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuXG4gICAgLy8gc2VwYXJhdGUgb3VyIGxhc3QgZXJyb3IgdG8gbWFrZSBkZWJ1Z2dpbmcgdmlhIGxvZyBlYXNpZXI6XG4gICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBSZXRyeUVycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNSZXRyeUVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgUmV0cnlFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgUmV0cnlFcnJvcikucmVhc29uID09PSAnc3RyaW5nJyAmJlxuICAgICAgQXJyYXkuaXNBcnJheSgoZXJyb3IgYXMgUmV0cnlFcnJvcikuZXJyb3JzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHJlYXNvbjogdGhpcy5yZWFzb24sXG4gICAgICBsYXN0RXJyb3I6IHRoaXMubGFzdEVycm9yLFxuICAgICAgZXJyb3JzOiB0aGlzLmVycm9ycyxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBMYW5ndWFnZU1vZGVsVjFJbWFnZVBhcnQsXG4gIExhbmd1YWdlTW9kZWxWMU1lc3NhZ2UsXG4gIExhbmd1YWdlTW9kZWxWMVByb21wdCxcbiAgTGFuZ3VhZ2VNb2RlbFYxVGV4dFBhcnQsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyBkb3dubG9hZCB9IGZyb20gJy4uLy4uL3V0aWwvZG93bmxvYWQnO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UgfSBmcm9tICcuLi9wcm9tcHQvbWVzc2FnZSc7XG5pbXBvcnQgeyBkZXRlY3RJbWFnZU1pbWVUeXBlIH0gZnJvbSAnLi4vdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUnO1xuaW1wb3J0IHsgSW1hZ2VQYXJ0LCBUZXh0UGFydCB9IGZyb20gJy4vY29udGVudC1wYXJ0JztcbmltcG9ydCB7IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSB9IGZyb20gJy4vZGF0YS1jb250ZW50JztcbmltcG9ydCB7IFZhbGlkYXRlZFByb21wdCB9IGZyb20gJy4vZ2V0LXZhbGlkYXRlZC1wcm9tcHQnO1xuaW1wb3J0IHsgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgfSBmcm9tICcuL2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPSB0cnVlLFxuICBkb3dubG9hZEltcGxlbWVudGF0aW9uID0gZG93bmxvYWQsXG59OiB7XG4gIHByb21wdDogVmFsaWRhdGVkUHJvbXB0O1xuICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICBkb3dubG9hZEltcGxlbWVudGF0aW9uPzogdHlwZW9mIGRvd25sb2FkO1xufSk6IFByb21pc2U8TGFuZ3VhZ2VNb2RlbFYxUHJvbXB0PiB7XG4gIGNvbnN0IGxhbmd1YWdlTW9kZWxNZXNzYWdlczogTGFuZ3VhZ2VNb2RlbFYxUHJvbXB0ID0gW107XG5cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCkge1xuICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ3N5c3RlbScsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cblxuICBjb25zdCBkb3dubG9hZGVkSW1hZ2VzID1cbiAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzIHx8IHByb21wdC5tZXNzYWdlcyA9PSBudWxsXG4gICAgICA/IG51bGxcbiAgICAgIDogYXdhaXQgZG93bmxvYWRJbWFnZXMocHJvbXB0Lm1lc3NhZ2VzLCBkb3dubG9hZEltcGxlbWVudGF0aW9uKTtcblxuICBjb25zdCBwcm9tcHRUeXBlID0gcHJvbXB0LnR5cGU7XG4gIHN3aXRjaCAocHJvbXB0VHlwZSkge1xuICAgIGNhc2UgJ3Byb21wdCc6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IHByb21wdC5wcm9tcHQgfV0sXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ21lc3NhZ2VzJzoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoXG4gICAgICAgICAgKG1lc3NhZ2UpOiBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlID0+XG4gICAgICAgICAgICBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkSW1hZ2VzKSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHByb21wdFR5cGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByb21wdCB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhbmd1YWdlTW9kZWxNZXNzYWdlcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgQ29yZU1lc3NhZ2UgdG8gYSBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBDb3JlTWVzc2FnZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIGRvd25sb2FkZWRJbWFnZXMgQSBtYXAgb2YgaW1hZ2UgVVJMcyB0byB0aGVpciBkb3dubG9hZGVkIGRhdGEuIE9ubHlcbiAqICAgYXZhaWxhYmxlIGlmIHRoZSBtb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGltYWdlIFVSTHMsIG51bGwgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UoXG4gIG1lc3NhZ2U6IENvcmVNZXNzYWdlLFxuICBkb3dubG9hZGVkSW1hZ2VzOiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHsgbWltZVR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDsgZGF0YTogVWludDhBcnJheSB9XG4gID4gfCBudWxsLFxuKTogTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgJ3N5c3RlbSc6IHtcbiAgICAgIHJldHVybiB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfTtcbiAgICB9XG5cbiAgICBjYXNlICd1c2VyJzoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6ICd0ZXh0JywgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgICAgKHBhcnQpOiBMYW5ndWFnZU1vZGVsVjFUZXh0UGFydCB8IExhbmd1YWdlTW9kZWxWMUltYWdlUGFydCA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuaW1hZ2UgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZGVkSW1hZ2VzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBwYXJ0LmltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRlZEltYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZGVkSW1hZ2VzW3BhcnQuaW1hZ2UudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogZG93bmxvYWRlZEltYWdlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUgPz8gZG93bmxvYWRlZEltYWdlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHN0cmluZyBpbWFnZSBwYXJ0cyB0byB1cmxzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LmltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXJ0LmltYWdlKTtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0dHA6JzpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlICdodHRwczonOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRlZEltYWdlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRlZEltYWdlID0gZG93bmxvYWRlZEltYWdlc1twYXJ0LmltYWdlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBkb3dubG9hZGVkSW1hZ2UuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSA/PyBkb3dubG9hZGVkSW1hZ2UubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGE6Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBwYXJ0LmltYWdlLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KCc7JylbMF0uc3BsaXQoJzonKVsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSBVUkwgZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7Z2V0RXJyb3JNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYFVuc3VwcG9ydGVkIFVSTCBwcm90b2NvbDogJHt1cmwucHJvdG9jb2x9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChfaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBVUkxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVVpbnQ4ID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KHBhcnQuaW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVaW50OCxcbiAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlID8/IGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2VVaW50OCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgJ2Fzc2lzdGFudCc6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6ICd0ZXh0JywgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0czpcbiAgICAgICAgICBwYXJ0ID0+IHBhcnQudHlwZSAhPT0gJ3RleHQnIHx8IHBhcnQudGV4dCAhPT0gJycsXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgJ3Rvb2wnOiB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHJvbGU7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoeyByb2xlOiBfZXhoYXVzdGl2ZUNoZWNrIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEltYWdlcyhcbiAgbWVzc2FnZXM6IENvcmVNZXNzYWdlW10sXG4gIGRvd25sb2FkSW1wbGVtZW50YXRpb246IHR5cGVvZiBkb3dubG9hZCxcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgeyBtaW1lVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkOyBkYXRhOiBVaW50OEFycmF5IH0+PiB7XG4gIGNvbnN0IHVybHMgPSBtZXNzYWdlc1xuICAgIC5maWx0ZXIobWVzc2FnZSA9PiBtZXNzYWdlLnJvbGUgPT09ICd1c2VyJylcbiAgICAubWFwKG1lc3NhZ2UgPT4gbWVzc2FnZS5jb250ZW50KVxuICAgIC5maWx0ZXIoKGNvbnRlbnQpOiBjb250ZW50IGlzIEFycmF5PFRleHRQYXJ0IHwgSW1hZ2VQYXJ0PiA9PlxuICAgICAgQXJyYXkuaXNBcnJheShjb250ZW50KSxcbiAgICApXG4gICAgLmZsYXQoKVxuICAgIC5maWx0ZXIoKHBhcnQpOiBwYXJ0IGlzIEltYWdlUGFydCA9PiBwYXJ0LnR5cGUgPT09ICdpbWFnZScpXG4gICAgLm1hcChwYXJ0ID0+IHBhcnQuaW1hZ2UpXG4gICAgLm1hcChwYXJ0ID0+XG4gICAgICAvLyBzdXBwb3J0IHN0cmluZyB1cmxzIGluIGltYWdlIHBhcnRzOlxuICAgICAgdHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnICYmXG4gICAgICAocGFydC5zdGFydHNXaXRoKCdodHRwOicpIHx8IHBhcnQuc3RhcnRzV2l0aCgnaHR0cHM6JykpXG4gICAgICAgID8gbmV3IFVSTChwYXJ0KVxuICAgICAgICA6IHBhcnQsXG4gICAgKVxuICAgIC5maWx0ZXIoKGltYWdlKTogaW1hZ2UgaXMgVVJMID0+IGltYWdlIGluc3RhbmNlb2YgVVJMKTtcblxuICAvLyBkb3dubG9hZCBpbWFnZXMgaW4gcGFyYWxsZWw6XG4gIGNvbnN0IGRvd25sb2FkZWRJbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB1cmxzLm1hcChhc3luYyB1cmwgPT4gKHtcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IGF3YWl0IGRvd25sb2FkSW1wbGVtZW50YXRpb24oeyB1cmwgfSksXG4gICAgfSkpLFxuICApO1xuXG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEltYWdlcy5tYXAoKHsgdXJsLCBkYXRhIH0pID0+IFt1cmwudG9TdHJpbmcoKSwgZGF0YV0pLFxuICApO1xufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX0Rvd25sb2FkRXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIERvd25sb2FkRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHVybDogc3RyaW5nO1xuICByZWFkb25seSBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICByZWFkb25seSBzdGF0dXNUZXh0Pzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsXG4gICAgICA/IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke3N0YXR1c0NvZGV9ICR7c3RhdHVzVGV4dH1gXG4gICAgICA6IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke2NhdXNlfWAsXG4gIH06IHtcbiAgICB1cmw6IHN0cmluZztcbiAgICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICAgIHN0YXR1c1RleHQ/OiBzdHJpbmc7XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgICBjYXVzZT86IHVua25vd247XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuXG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBEb3dubG9hZEVycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNEb3dubG9hZEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgRG93bmxvYWRFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgRG93bmxvYWRFcnJvcikudXJsID09PSAnc3RyaW5nJyAmJlxuICAgICAgKChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNDb2RlID09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNDb2RlID09PSAnbnVtYmVyJykgJiZcbiAgICAgICgoZXJyb3IgYXMgRG93bmxvYWRFcnJvcikuc3RhdHVzVGV4dCA9PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiAoZXJyb3IgYXMgRG93bmxvYWRFcnJvcikuc3RhdHVzVGV4dCA9PT0gJ3N0cmluZycpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IERvd25sb2FkRXJyb3IgfSBmcm9tICcuL2Rvd25sb2FkLWVycm9yJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHtcbiAgdXJsLFxuICBmZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2gsXG59OiB7XG4gIHVybDogVVJMO1xuICBmZXRjaEltcGxlbWVudGF0aW9uPzogdHlwZW9mIGZldGNoO1xufSk6IFByb21pc2U8e1xuICBkYXRhOiBVaW50OEFycmF5O1xuICBtaW1lVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufT4ge1xuICBjb25zdCB1cmxUZXh0ID0gdXJsLnRvU3RyaW5nKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGxlbWVudGF0aW9uKHVybFRleHQpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1pbWVUeXBlOiByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgPz8gdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cbiIsImNvbnN0IG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2dpZicgYXMgY29uc3QsIGJ5dGVzOiBbMHg0NywgMHg0OSwgMHg0Nl0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3BuZycgYXMgY29uc3QsIGJ5dGVzOiBbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0N10gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2pwZWcnIGFzIGNvbnN0LCBieXRlczogWzB4ZmYsIDB4ZDhdIH0sXG4gIHsgbWltZVR5cGU6ICdpbWFnZS93ZWJwJyBhcyBjb25zdCwgYnl0ZXM6IFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoXG4gIGltYWdlOiBVaW50OEFycmF5LFxuKTogJ2ltYWdlL2pwZWcnIHwgJ2ltYWdlL3BuZycgfCAnaW1hZ2UvZ2lmJyB8ICdpbWFnZS93ZWJwJyB8IHVuZGVmaW5lZCB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoXG4gICAgICBpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmXG4gICAgICBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gJy4vaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3InO1xuXG4vKipcbkRhdGEgY29udGVudC4gQ2FuIGVpdGhlciBiZSBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZywgYSBVaW50OEFycmF5LCBhbiBBcnJheUJ1ZmZlciwgb3IgYSBCdWZmZXIuXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFDb250ZW50ID0gc3RyaW5nIHwgVWludDhBcnJheSB8IEFycmF5QnVmZmVyIHwgQnVmZmVyO1xuXG4vKipcbkNvbnZlcnRzIGRhdGEgY29udGVudCB0byBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy5cblxuQHBhcmFtIGNvbnRlbnQgLSBEYXRhIGNvbnRlbnQgdG8gY29udmVydC5cbkByZXR1cm5zIEJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudDogRGF0YUNvbnRlbnQpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgVWludDhBcnJheS5cblxuQHBhcmFtIGNvbnRlbnQgLSBEYXRhIGNvbnRlbnQgdG8gY29udmVydC5cbkByZXR1cm5zIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoXG4gIGNvbnRlbnQ6IERhdGFDb250ZW50LFxuKTogVWludDhBcnJheSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAnSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIG1lZGlhLicsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cblxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIHN0cmluZyBvZiB0ZXh0LlxuICpcbiAqIEBwYXJhbSB1aW50OEFycmF5IC0gVGhlIFVpbnQ4QXJyYXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb1RleHQodWludDhBcnJheTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50OEFycmF5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGRlY29kaW5nIFVpbnQ4QXJyYXkgdG8gdGV4dCcpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfSW52YWxpZERhdGFDb250ZW50RXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIEludmFsaWREYXRhQ29udGVudEVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICByZWFkb25seSBjb250ZW50OiB1bmtub3duO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRhIGNvbnRlbnQuIEV4cGVjdGVkIGEgYmFzZTY0IHN0cmluZywgVWludDhBcnJheSwgQXJyYXlCdWZmZXIsIG9yIEJ1ZmZlciwgYnV0IGdvdCAke3R5cGVvZiBjb250ZW50fS5gLFxuICB9OiB7XG4gICAgY29udGVudDogdW5rbm93bjtcbiAgICBjYXVzZT86IHVua25vd247XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZERhdGFDb250ZW50RXJyb3IoXG4gICAgZXJyb3I6IHVua25vd24sXG4gICk6IGVycm9yIGlzIEludmFsaWREYXRhQ29udGVudEVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgKGVycm9yIGFzIEludmFsaWREYXRhQ29udGVudEVycm9yKS5jb250ZW50ICE9IG51bGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcblxuY29uc3QgbmFtZSA9ICdBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHJvbGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYCxcbiAgfToge1xuICAgIHJvbGU6IHN0cmluZztcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlIH0pO1xuXG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yKFxuICAgIGVycm9yOiB1bmtub3duLFxuICApOiBlcnJvciBpcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IpLnJvbGUgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENvcmVNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4vcHJvbXB0JztcblxuZXhwb3J0IHR5cGUgVmFsaWRhdGVkUHJvbXB0ID1cbiAgfCB7XG4gICAgICB0eXBlOiAncHJvbXB0JztcbiAgICAgIHByb21wdDogc3RyaW5nO1xuICAgICAgbWVzc2FnZXM6IHVuZGVmaW5lZDtcbiAgICAgIHN5c3RlbT86IHN0cmluZztcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogJ21lc3NhZ2VzJztcbiAgICAgIHByb21wdDogdW5kZWZpbmVkO1xuICAgICAgbWVzc2FnZXM6IENvcmVNZXNzYWdlW107XG4gICAgICBzeXN0ZW0/OiBzdHJpbmc7XG4gICAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZFByb21wdChwcm9tcHQ6IFByb21wdCk6IFZhbGlkYXRlZFByb21wdCB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkJyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWUnLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHByb21wdC5tZXNzYWdlcykge1xuICAgICAgaWYgKG1lc3NhZ2Uucm9sZSA9PT0gJ3N5c3RlbScgJiYgdHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIG1lc3NhZ2U6ICdzeXN0ZW0gbWVzc2FnZSBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvbXB0LnByb21wdCAhPSBudWxsXG4gICAgPyB7XG4gICAgICAgIHR5cGU6ICdwcm9tcHQnLFxuICAgICAgICBwcm9tcHQ6IHByb21wdC5wcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzOiB1bmRlZmluZWQsXG4gICAgICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbSxcbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgdHlwZTogJ21lc3NhZ2VzJyxcbiAgICAgICAgcHJvbXB0OiB1bmRlZmluZWQsXG4gICAgICAgIG1lc3NhZ2VzOiBwcm9tcHQubWVzc2FnZXMhLCAvLyBvbmx5IHBvc3NpYmxlIGNhc2UgYmMgb2YgY2hlY2tzIGFib3ZlXG4gICAgICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbSxcbiAgICAgIH07XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfSW52YWxpZEFyZ3VtZW50RXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICByZWFkb25seSBwYXJhbWV0ZXI6IHN0cmluZztcbiAgcmVhZG9ubHkgdmFsdWU6IHVua25vd247XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcmFtZXRlcixcbiAgICB2YWx1ZSxcbiAgICBtZXNzYWdlLFxuICB9OiB7XG4gICAgcGFyYW1ldGVyOiBzdHJpbmc7XG4gICAgdmFsdWU6IHVua25vd247XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZSxcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFyZ3VtZW50IGZvciBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJ9OiAke21lc3NhZ2V9YCxcbiAgICB9KTtcblxuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZEFyZ3VtZW50RXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRBcmd1bWVudEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZEFyZ3VtZW50RXJyb3Ige1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBlcnJvci5uYW1lID09PSBuYW1lICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yKS5wYXJhbWV0ZXIgPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yKS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICApO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgcGFyYW1ldGVyOiB0aGlzLnBhcmFtZXRlcixcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzL2ludmFsaWQtYXJndW1lbnQtZXJyb3InO1xuaW1wb3J0IHsgQ2FsbFNldHRpbmdzIH0gZnJvbSAnLi9jYWxsLXNldHRpbmdzJztcblxuLyoqXG4gKiBWYWxpZGF0ZXMgY2FsbCBzZXR0aW5ncyBhbmQgc2V0cyBkZWZhdWx0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHN0b3BTZXF1ZW5jZXMsXG4gIHNlZWQsXG4gIG1heFJldHJpZXMsXG59OiBDYWxsU2V0dGluZ3MpOiBDYWxsU2V0dGluZ3Mge1xuICBpZiAobWF4VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4VG9rZW5zJyxcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogJ21heFRva2VucyBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1heFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFRva2VucycsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhUb2tlbnMgbXVzdCBiZSA+PSAxJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiAndGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAndG9wUCcsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiAndG9wUCBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogJ3ByZXNlbmNlUGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6ICdmcmVxdWVuY3lQZW5hbHR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnc2VlZCcsXG4gICAgICAgIHZhbHVlOiBzZWVkLFxuICAgICAgICBtZXNzYWdlOiAnc2VlZCBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4UmV0cmllcycsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiAnbWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhSZXRyaWVzJyxcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhSZXRyaWVzIG11c3QgYmUgPj0gMCcsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgPz8gMCxcbiAgICB0b3BQLFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHN0b3BTZXF1ZW5jZXM6XG4gICAgICBzdG9wU2VxdWVuY2VzICE9IG51bGwgJiYgc3RvcFNlcXVlbmNlcy5sZW5ndGggPiAwXG4gICAgICAgID8gc3RvcFNlcXVlbmNlc1xuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICBzZWVkLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgPz8gMixcbiAgfTtcbn1cbiIsIi8qKlxuUmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIGEgcHJvbXB0IGFuZCBjb21wbGV0aW9uLlxuICovXG5leHBvcnQgdHlwZSBDb21wbGV0aW9uVG9rZW5Vc2FnZSA9IHtcbiAgLyoqXG5UaGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRUb2tlbnM6IG51bWJlcjtcblxuICAvKipcblRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gdGhlIGNvbXBsZXRpb24uXG4gKi9cbiAgY29tcGxldGlvblRva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuVGhlIHRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCAocHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2VucykuXG4gICAqL1xuICB0b3RhbFRva2VuczogbnVtYmVyO1xufTtcblxuLyoqXG5SZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gYW4gZW1iZWRkaW5nLlxuICovXG5leHBvcnQgdHlwZSBFbWJlZGRpbmdUb2tlblVzYWdlID0ge1xuICAvKipcblRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gdGhlIGVtYmVkZGluZy5cbiAgICovXG4gIHRva2VuczogbnVtYmVyO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBsZXRpb25Ub2tlblVzYWdlKHVzYWdlOiB7XG4gIHByb21wdFRva2VuczogbnVtYmVyO1xuICBjb21wbGV0aW9uVG9rZW5zOiBudW1iZXI7XG59KTogQ29tcGxldGlvblRva2VuVXNhZ2Uge1xuICByZXR1cm4ge1xuICAgIHByb21wdFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgIGNvbXBsZXRpb25Ub2tlbnM6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgdG90YWxUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyArIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBWYWxpZGF0b3IsIHZhbGlkYXRvclN5bWJvbCB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgSlNPTlNjaGVtYTcgfSBmcm9tICdqc29uLXNjaGVtYSc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSAnem9kLXRvLWpzb24tc2NoZW1hJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hcmsgc2NoZW1hcyBzbyB3ZSBjYW4gc3VwcG9ydCBib3RoIFpvZCBhbmQgY3VzdG9tIHNjaGVtYXMuXG4gKi9cbmNvbnN0IHNjaGVtYVN5bWJvbCA9IFN5bWJvbC5mb3IoJ3ZlcmNlbC5haS5zY2hlbWEnKTtcblxuZXhwb3J0IHR5cGUgU2NoZW1hPE9CSkVDVCA9IHVua25vd24+ID0gVmFsaWRhdG9yPE9CSkVDVD4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hcmsgc2NoZW1hcyBzbyB3ZSBjYW4gc3VwcG9ydCBib3RoIFpvZCBhbmQgY3VzdG9tIHNjaGVtYXMuXG4gICAqL1xuICBbc2NoZW1hU3ltYm9sXTogdHJ1ZTtcblxuICAvKipcbiAgICogU2NoZW1hIHR5cGUgZm9yIGluZmVyZW5jZS5cbiAgICovXG4gIF90eXBlOiBPQkpFQ1Q7XG5cbiAgLyoqXG4gICAqIFRoZSBKU09OIFNjaGVtYSBmb3IgdGhlIHNjaGVtYS4gSXQgaXMgcGFzc2VkIHRvIHRoZSBwcm92aWRlcnMuXG4gICAqL1xuICByZWFkb25seSBqc29uU2NoZW1hOiBKU09OU2NoZW1hNztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc2NoZW1hIHVzaW5nIGEgSlNPTiBTY2hlbWEuXG4gKlxuICogQHBhcmFtIGpzb25TY2hlbWEgVGhlIEpTT04gU2NoZW1hIGZvciB0aGUgc2NoZW1hLlxuICogQHBhcmFtIG9wdGlvbnMudmFsaWRhdGUgT3B0aW9uYWwuIEEgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgdGhlIHNjaGVtYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25TY2hlbWE8T0JKRUNUID0gdW5rbm93bj4oXG4gIGpzb25TY2hlbWE6IEpTT05TY2hlbWE3LFxuICB7XG4gICAgdmFsaWRhdGUsXG4gIH06IHtcbiAgICB2YWxpZGF0ZT86IChcbiAgICAgIHZhbHVlOiB1bmtub3duLFxuICAgICkgPT4geyBzdWNjZXNzOiB0cnVlOyB2YWx1ZTogT0JKRUNUIH0gfCB7IHN1Y2Nlc3M6IGZhbHNlOyBlcnJvcjogRXJyb3IgfTtcbiAgfSA9IHt9LFxuKTogU2NoZW1hPE9CSkVDVD4ge1xuICByZXR1cm4ge1xuICAgIFtzY2hlbWFTeW1ib2xdOiB0cnVlLFxuICAgIF90eXBlOiB1bmRlZmluZWQgYXMgT0JKRUNULCAvLyBzaG91bGQgbmV2ZXIgYmUgdXNlZCBkaXJlY3RseVxuICAgIFt2YWxpZGF0b3JTeW1ib2xdOiB0cnVlLFxuICAgIGpzb25TY2hlbWEsXG4gICAgdmFsaWRhdGUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU2NoZW1hKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU2NoZW1hIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICBzY2hlbWFTeW1ib2wgaW4gdmFsdWUgJiZcbiAgICB2YWx1ZVtzY2hlbWFTeW1ib2xdID09PSB0cnVlICYmXG4gICAgJ2pzb25TY2hlbWEnIGluIHZhbHVlICYmXG4gICAgJ3ZhbGlkYXRlJyBpbiB2YWx1ZVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNTY2hlbWE8T0JKRUNUPihcbiAgc2NoZW1hOiB6LlNjaGVtYTxPQkpFQ1QsIHouWm9kVHlwZURlZiwgYW55PiB8IFNjaGVtYTxPQkpFQ1Q+LFxuKTogU2NoZW1hPE9CSkVDVD4ge1xuICByZXR1cm4gaXNTY2hlbWEoc2NoZW1hKSA/IHNjaGVtYSA6IHpvZFNjaGVtYShzY2hlbWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gem9kU2NoZW1hPE9CSkVDVD4oXG4gIHpvZFNjaGVtYTogei5TY2hlbWE8T0JKRUNULCB6LlpvZFR5cGVEZWYsIGFueT4sXG4pOiBTY2hlbWE8T0JKRUNUPiB7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgIC8vIHdlIGFzc3VtZSB0aGF0IHpvZFRvSnNvblNjaGVtYSB3aWxsIHJldHVybiBhIHZhbGlkIEpTT05TY2hlbWE3OlxuICAgIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEpIGFzIEpTT05TY2hlbWE3LFxuICAgIHtcbiAgICAgIHZhbGlkYXRlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYS5zYWZlUGFyc2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3NcbiAgICAgICAgICA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH1cbiAgICAgICAgICA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgICAgIH0sXG4gICAgfSxcbiAgKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KFxuICBvYmplY3Q6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkIHwgbnVsbCxcbik6IG9iamVjdCBpcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA+IDA7XG59XG4iLCJpbXBvcnQge1xuICBMYW5ndWFnZU1vZGVsVjFGdW5jdGlvblRvb2wsXG4gIExhbmd1YWdlTW9kZWxWMVRvb2xDaG9pY2UsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgQ29yZVRvb2wgfSBmcm9tICcuLi90b29sL3Rvb2wnO1xuaW1wb3J0IHsgQ29yZVRvb2xDaG9pY2UgfSBmcm9tICcuLi90eXBlcy9sYW5ndWFnZS1tb2RlbCc7XG5pbXBvcnQgeyBpc05vbkVtcHR5T2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0JztcbmltcG9ydCB7IGFzU2NoZW1hIH0gZnJvbSAnLi4vdXRpbC9zY2hlbWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZTxcbiAgVE9PTFMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBDb3JlVG9vbD4sXG4+KHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG59OiB7XG4gIHRvb2xzOiBUT09MUyB8IHVuZGVmaW5lZDtcbiAgdG9vbENob2ljZTogQ29yZVRvb2xDaG9pY2U8VE9PTFM+IHwgdW5kZWZpbmVkO1xufSk6IHtcbiAgdG9vbHM6IExhbmd1YWdlTW9kZWxWMUZ1bmN0aW9uVG9vbFtdIHwgdW5kZWZpbmVkO1xuICB0b29sQ2hvaWNlOiBMYW5ndWFnZU1vZGVsVjFUb29sQ2hvaWNlIHwgdW5kZWZpbmVkO1xufSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHVuZGVmaW5lZCxcbiAgICAgIHRvb2xDaG9pY2U6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b29sczogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2xdKSA9PiAoe1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgIG5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgIHBhcmFtZXRlcnM6IGFzU2NoZW1hKHRvb2wucGFyYW1ldGVycykuanNvblNjaGVtYSxcbiAgICB9KSksXG4gICAgdG9vbENob2ljZTpcbiAgICAgIHRvb2xDaG9pY2UgPT0gbnVsbFxuICAgICAgICA/IHsgdHlwZTogJ2F1dG8nIH1cbiAgICAgICAgOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfVxuICAgICAgICA6IHsgdHlwZTogJ3Rvb2wnIGFzIGNvbnN0LCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSBhcyBzdHJpbmcgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IsIGdldEVycm9yTWVzc2FnZSB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHRvb2xOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRvb2xBcmdzOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xBcmdzLFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBhcmd1bWVudHMgZm9yIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlKFxuICAgICAgY2F1c2UsXG4gICAgKX1gLFxuICB9OiB7XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgICB0b29sQXJnczogc3RyaW5nO1xuICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgY2F1c2U6IHVua25vd247XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuXG4gICAgdGhpcy50b29sQXJncyA9IHRvb2xBcmdzO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcihcbiAgICBlcnJvcjogdW5rbm93bixcbiAgKTogZXJyb3IgaXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcikudG9vbE5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IpLnRvb2xBcmdzID09PSAnc3RyaW5nJ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRoaXMudG9vbEFyZ3MsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX05vU3VjaFRvb2xFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgTm9TdWNoVG9vbEVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICByZWFkb25seSB0b29sTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBhdmFpbGFibGVUb29sczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xOYW1lLFxuICAgIGF2YWlsYWJsZVRvb2xzID0gdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2UgPSBgTW9kZWwgdHJpZWQgdG8gY2FsbCB1bmF2YWlsYWJsZSB0b29sICcke3Rvb2xOYW1lfScuICR7XG4gICAgICBhdmFpbGFibGVUb29scyA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gJ05vIHRvb2xzIGFyZSBhdmFpbGFibGUuJ1xuICAgICAgICA6IGBBdmFpbGFibGUgdG9vbHM6ICR7YXZhaWxhYmxlVG9vbHMuam9pbignLCAnKX0uYFxuICAgIH1gLFxuICB9OiB7XG4gICAgdG9vbE5hbWU6IHN0cmluZztcbiAgICBhdmFpbGFibGVUb29scz86IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG5cbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBOb1N1Y2hUb29sRXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaFRvb2xFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIE5vU3VjaFRvb2xFcnJvciB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIGVycm9yLm5hbWUgPT09IG5hbWUgJiZcbiAgICAgICd0b29sTmFtZScgaW4gZXJyb3IgJiZcbiAgICAgIGVycm9yLnRvb2xOYW1lICE9IHVuZGVmaW5lZCAmJlxuICAgICAgdHlwZW9mIGVycm9yLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG5cbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IHRoaXMuYXZhaWxhYmxlVG9vbHMsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyLFxuICB0eXBlIEV2ZW50U291cmNlUGFyc2VyLFxuICB0eXBlIFBhcnNlZEV2ZW50LFxuICB0eXBlIFJlY29ubmVjdEludGVydmFsLFxufSBmcm9tICdldmVudHNvdXJjZS1wYXJzZXInO1xuaW1wb3J0IHsgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIH0gZnJvbSAnLi9vcGVuYWktc3RyZWFtJztcblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGxQYXlsb2FkIHtcbiAgbmFtZTogc3RyaW5nO1xuICBhcmd1bWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufVxuZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbFBheWxvYWQge1xuICB0b29sczoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgICBmdW5jOiB7XG4gICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICBhcmd1bWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH07XG4gIH1bXTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIGhlbHBlciBjYWxsYmFjayBtZXRob2RzIGZvciBBSVN0cmVhbSBzdHJlYW0gbGlmZWN5Y2xlIGV2ZW50cy5cbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMge1xuICAvKiogYG9uU3RhcnRgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgaW5pdGlhbGl6ZWQuICovXG4gIG9uU3RhcnQ/OiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvbkNvbXBsZXRpb25gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuICovXG4gIG9uQ29tcGxldGlvbj86IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uRmluYWxgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgY2xvc2VkIHdpdGggdGhlIGZpbmFsIGNvbXBsZXRpb24gbWVzc2FnZS4gKi9cbiAgb25GaW5hbD86IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uVG9rZW5gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuICovXG4gIG9uVG9rZW4/OiAodG9rZW46IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25UZXh0YDogQ2FsbGVkIGZvciBlYWNoIHRleHQgY2h1bmsuICovXG4gIG9uVGV4dD86ICh0ZXh0OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBmbGFnIGlzIG5vIGxvbmdlciB1c2VkIGFuZCBvbmx5IHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICogWW91IGNhbiByZW1vdmUgaXQgZnJvbSB5b3VyIGNvZGUuXG4gICAqL1xuICBleHBlcmltZW50YWxfc3RyZWFtRGF0YT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIEFJU3RyZWFtUGFyc2VyLlxuICogQGludGVyZmFjZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50ICh0eXBlKSBmcm9tIHRoZSBzZXJ2ZXIgc2lkZSBldmVudCBzdHJlYW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1QYXJzZXJPcHRpb25zIHtcbiAgZXZlbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3VzdG9tIHBhcnNlciBmb3IgQUlTdHJlYW0gZGF0YS5cbiAqIEBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGRhdGEgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlck9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHBhcnNlci5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB2b2lkfSBUaGUgcGFyc2VkIGRhdGEgb3Igdm9pZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbVBhcnNlciB7XG4gIChkYXRhOiBzdHJpbmcsIG9wdGlvbnM6IEFJU3RyZWFtUGFyc2VyT3B0aW9ucyk6XG4gICAgfCBzdHJpbmdcbiAgICB8IHZvaWRcbiAgICB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRyYW5zZm9ybVN0cmVhbSB0aGF0IHBhcnNlcyBldmVudHMgZnJvbSBhbiBFdmVudFNvdXJjZSBzdHJlYW0gdXNpbmcgYSBjdXN0b20gcGFyc2VyLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlcn0gY3VzdG9tUGFyc2VyIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGV2ZW50IGRhdGEuXG4gKiBAcmV0dXJucyB7VHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIHN0cmluZz59IFRyYW5zZm9ybVN0cmVhbSBwYXJzaW5nIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoXG4gIGN1c3RvbVBhcnNlcj86IEFJU3RyZWFtUGFyc2VyLFxuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0+IHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyOiBFdmVudFNvdXJjZVBhcnNlcjtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudDogUGFyc2VkRXZlbnQgfCBSZWNvbm5lY3RJbnRlcnZhbCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgnZGF0YScgaW4gZXZlbnQgJiZcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2V2ZW50JyAmJlxuICAgICAgICAgICAgICBldmVudC5kYXRhID09PSAnW0RPTkVdJykgfHxcbiAgICAgICAgICAgIC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgICAoZXZlbnQgYXMgYW55KS5ldmVudCA9PT0gJ2RvbmUnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnZGF0YScgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXJcbiAgICAgICAgICAgICAgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKSBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW5jb2RlcyBpbnB1dCBtZXNzYWdlcyBhbmQgaW52b2tlcyBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBUaGUgdHJhbnNmb3JtIHN0cmVhbSB1c2VzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgdG8gZXhlY3V0ZSBjdXN0b20gbG9naWMgYXQgZGlmZmVyZW50IHN0YWdlcyBvZiB0aGUgc3RyZWFtJ3MgbGlmZWN5Y2xlLlxuICogLSBgb25TdGFydGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBpbml0aWFsaXplZC5cbiAqIC0gYG9uVG9rZW5gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuXG4gKiAtIGBvbkNvbXBsZXRpb25gOiBDYWxsZWQgZXZlcnkgdGltZSBhbiBBSVN0cmVhbSBjb21wbGV0aW9uIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuIFRoaXMgY2FuIG9jY3VyIG11bHRpcGxlIHRpbWVzIHdoZW4gdXNpbmcgZS5nLiBPcGVuQUkgZnVuY3Rpb25zXG4gKiAtIGBvbkZpbmFsYDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGNsb3NlZCB3aXRoIHRoZSBmaW5hbCBjb21wbGV0aW9uIG1lc3NhZ2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBwcm9jZXNzIGEgc3RyZWFtIG9mIG1lc3NhZ2VzIGFuZCBwZXJmb3JtIHNwZWNpZmljIGFjdGlvbnMgZHVyaW5nIHRoZSBzdHJlYW0ncyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIHtBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnN9IFtjYWxsYmFja3NdIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybVN0cmVhbTxzdHJpbmcsIFVpbnQ4QXJyYXk+fSBBIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbmNvZGVzIGlucHV0IG1lc3NhZ2VzIGFzIFVpbnQ4QXJyYXkgYW5kIGFsbG93cyB0aGUgZXhlY3V0aW9uIG9mIGN1c3RvbSBsb2dpYyB0aHJvdWdoIGNhbGxiYWNrcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgY2FsbGJhY2tzID0ge1xuICogICBvblN0YXJ0OiBhc3luYyAoKSA9PiBjb25zb2xlLmxvZygnU3RyZWFtIHN0YXJ0ZWQnKSxcbiAqICAgb25Ub2tlbjogYXN5bmMgKHRva2VuKSA9PiBjb25zb2xlLmxvZyhgVG9rZW46ICR7dG9rZW59YCksXG4gKiAgIG9uQ29tcGxldGlvbjogYXN5bmMgKGNvbXBsZXRpb24pID0+IGNvbnNvbGUubG9nKGBDb21wbGV0aW9uOiAke2NvbXBsZXRpb259YClcbiAqICAgb25GaW5hbDogYXN5bmMgKCkgPT4gZGF0YS5jbG9zZSgpXG4gKiB9O1xuICogY29uc3QgdHJhbnNmb3JtZXIgPSBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gIGNiOiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgfCBPcGVuQUlTdHJlYW1DYWxsYmFja3MgfCB1bmRlZmluZWQsXG4pOiBUcmFuc2Zvcm1TdHJlYW08c3RyaW5nIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfSwgVWludDhBcnJheT4ge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gJyc7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydCkgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuXG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpKTtcblxuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IGNvbnRlbnQ7XG5cbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbikgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZmx1c2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICAvLyBJZiBpdCdzIE9wZW5BSUNhbGxiYWNrcywgaXQgaGFzIGFuIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB3aGljaCBtZWFucyB0aGF0IHRoZSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lclxuICAgICAgLy8gd2lsbCBoYW5kbGUgY2FsbGluZyBvbkNvbXBsZXRlLlxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKFxuICBjYWxsYmFja3M6IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB8IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyxcbik6IGNhbGxiYWNrcyBpcyBPcGVuQUlTdHJlYW1DYWxsYmFja3Mge1xuICByZXR1cm4gJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCcgaW4gY2FsbGJhY2tzO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RhdGVmdWwgZnVuY3Rpb24gdGhhdCwgd2hlbiBpbnZva2VkLCB0cmltcyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIGZyb20gdGhlIGlucHV0IHRleHQuIFRoZSB0cmltbWluZyBvbmx5IG9jY3VycyBvbiB0aGUgZmlyc3QgaW52b2NhdGlvbiwgZW5zdXJpbmcgdGhhdFxuICogc3Vic2VxdWVudCBjYWxscyBkbyBub3QgYWx0ZXIgdGhlIGlucHV0IHRleHQuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBpbiBzY2VuYXJpb3NcbiAqIHdoZXJlIGEgdGV4dCBzdHJlYW0gaXMgYmVpbmcgcHJvY2Vzc2VkIGFuZCBvbmx5IHRoZSBpbml0aWFsIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIHJlbW92ZWQuXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nKTogc3RyaW5nfSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzdHJpbmcgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBzdHJpbmdcbiAqIHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQgaWYgaXQgaXMgdGhlIGZpcnN0IGludm9jYXRpb247IG90aGVyd2lzZSwgaXQgcmV0dXJucyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB0cmltU3RhcnQgPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICogY29uc3Qgb3V0cHV0MSA9IHRyaW1TdGFydChcIiAgIHRleHRcIik7IC8vIFwidGV4dFwiXG4gKiBjb25zdCBvdXRwdXQyID0gdHJpbVN0YXJ0KFwiICAgdGV4dFwiKTsgLy8gXCIgICB0ZXh0XCJcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpOiAodGV4dDogc3RyaW5nKSA9PiBzdHJpbmcge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG5cbiAgcmV0dXJuICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KSBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBSZWFkYWJsZVN0cmVhbSBjcmVhdGVkIGZyb20gdGhlIHJlc3BvbnNlLCBwYXJzZWQgYW5kIGhhbmRsZWQgd2l0aCBjdXN0b20gbG9naWMuXG4gKiBUaGUgc3RyZWFtIGdvZXMgdGhyb3VnaCB0d28gdHJhbnNmb3JtYXRpb24gc3RhZ2VzLCBmaXJzdCBwYXJzaW5nIHRoZSBldmVudHMgYW5kIHRoZW5cbiAqIGludm9raW5nIHRoZSBwcm92aWRlZCBjYWxsYmFja3MuXG4gKlxuICogRm9yIDJ4eCBIVFRQIHJlc3BvbnNlczpcbiAqIC0gVGhlIGZ1bmN0aW9uIGNvbnRpbnVlcyB3aXRoIHN0YW5kYXJkIHN0cmVhbSBwcm9jZXNzaW5nLlxuICpcbiAqIEZvciBub24tMnh4IEhUVFAgcmVzcG9uc2VzOlxuICogLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBkZWZpbmVkLCBpdCBhc3luY2hyb25vdXNseSBleHRyYWN0cyBhbmQgZGVjb2RlcyB0aGUgcmVzcG9uc2UgYm9keS5cbiAqIC0gSXQgdGhlbiBjcmVhdGVzIGEgY3VzdG9tIFJlYWRhYmxlU3RyZWFtIHRvIHByb3BhZ2F0ZSBhIGRldGFpbGVkIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyfSBjdXN0b21QYXJzZXIgLSBUaGUgY3VzdG9tIHBhcnNlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zfSBjYWxsYmFja3MgLSBUaGUgY2FsbGJhY2tzLlxuICogQHJldHVybiB7UmVhZGFibGVTdHJlYW19IFRoZSBBSVN0cmVhbS5cbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcmVzcG9uc2UgaXMgbm90IE9LLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQUlTdHJlYW0oXG4gIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgY3VzdG9tUGFyc2VyPzogQUlTdHJlYW1QYXJzZXIsXG4gIGNhbGxiYWNrcz86IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyxcbik6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGBSZXNwb25zZSBlcnJvcjogJHtlcnJvclRleHR9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKCdSZXNwb25zZSBlcnJvcjogTm8gcmVzcG9uc2UgYm9keScpKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuXG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW1cbiAgICAucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cblxuLy8gb3V0cHV0cyBsaW5lcyBsaWtlXG4vLyAwOiBjaHVua1xuLy8gMDogbW9yZSBjaHVua1xuLy8gMTogYSBmY3QgY2FsbFxuLy8gejogYWRkZWQgZGF0YSBmcm9tIERhdGFcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFJlYWRhYmxlU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgY2xvc2VzIHVwb24gY3JlYXRpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYXMgYSBmYWxsYmFjayBmb3IgY3JlYXRpbmcgYSBSZWFkYWJsZVN0cmVhbSB3aGVuIHRoZSByZXNwb25zZSBib2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkLFxuICogZW5zdXJpbmcgdGhhdCB0aGUgc3Vic2VxdWVudCBwaXBlbGluZSBwcm9jZXNzaW5nIGRvZXNuJ3QgZmFpbCBkdWUgdG8gYSBsYWNrIG9mIGEgc3RyZWFtLlxuICpcbiAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbX0gQW4gZW1wdHkgYW5kIGNsb3NlZCBSZWFkYWJsZVN0cmVhbSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIFJlYWRhYmxlU3RyZWFtLmZyb20oYXN5bmNJdGVyYWJsZSksIHdoaWNoIGlzbid0IGRvY3VtZW50ZWQgaW4gTUROIGFuZCBpc24ndCBpbXBsZW1lbnRlZCBpbiBub2RlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL2NvbW1pdC84ZDdhMGJmMjZlYjJjYzIzZTg4NGRkYmFhYzdjMWRhNGI5MWNmMmJjXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlPFQ+KGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFQ+KSB7XG4gIGxldCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtPFQ+KHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKSBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGF3YWl0IGl0LnJldHVybj8uKHJlYXNvbik7XG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBKU09OVmFsdWUsIGZvcm1hdFN0cmVhbVBhcnQgfSBmcm9tICdAYWktc2RrL3VpLXV0aWxzJztcblxuY29uc3QgU1RSRUFNX0RBVEFfV0FSTklOR19USU1FX01TID0gMTUgKiAxMDAwO1xuXG4vKipcbiAqIEEgc3RyZWFtIHdyYXBwZXIgdG8gc2VuZCBjdXN0b20gSlNPTi1lbmNvZGVkIGRhdGEgYmFjayB0byB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtRGF0YSB7XG4gIHByaXZhdGUgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIHByaXZhdGUgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFVpbnQ4QXJyYXk+IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+O1xuXG4gIHByaXZhdGUgaXNDbG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyBjb250cm9sbGVyID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICAgICAgICAvLyBTZXQgYSB0aW1lb3V0IHRvIHNob3cgYSB3YXJuaW5nIGlmIHRoZSBzdHJlYW0gaXMgbm90IGNsb3NlZCB3aXRoaW4gMyBzZWNvbmRzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIHNlbGYud2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ1RoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgPycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIFNUUkVBTV9EQVRBX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgLy8gTm8tb3A6IHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgc3BlY2lhbCBvbiBwdWxsXG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG5cbiAgICAvLyBDbGVhciB0aGUgd2FybmluZyB0aW1lb3V0IGlmIHRoZSBzdHJlYW0gaXMgY2xvc2VkXG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBhcHBlbmQodmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnZGF0YScsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG5cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnbWVzc2FnZV9hbm5vdGF0aW9ucycsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQSBUcmFuc2Zvcm1TdHJlYW0gZm9yIExMTXMgdGhhdCBkbyBub3QgaGF2ZSB0aGVpciBvd24gdHJhbnNmb3JtIHN0cmVhbSBoYW5kbGVycyBtYW5hZ2luZyBlbmNvZGluZyAoZS5nLiBPcGVuQUlTdHJlYW0gaGFzIG9uZSBmb3IgZnVuY3Rpb24gY2FsbCBoYW5kbGluZykuXG4gKiBUaGlzIGFzc3VtZXMgZXZlcnkgY2h1bmsgaXMgYSAndGV4dCcgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGBTdHJlYW1EYXRhYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgZXh0ZW5kcyBTdHJlYW1EYXRhIHt9XG4iLCJpbXBvcnQge1xuICBDcmVhdGVNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgZm9ybWF0U3RyZWFtUGFydCxcbn0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5pbXBvcnQge1xuICBBSVN0cmVhbSxcbiAgRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgVG9vbENhbGxQYXlsb2FkLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIsXG4gIHR5cGUgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxufSBmcm9tICcuL2FpLXN0cmVhbSc7XG5pbXBvcnQgeyBBenVyZUNoYXRDb21wbGV0aW9ucyB9IGZyb20gJy4vYXp1cmUtb3BlbmFpLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciB9IGZyb20gJy4vc3RyZWFtLWRhdGEnO1xuXG5leHBvcnQgdHlwZSBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTA2MTMnLFxuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICBmdW5jdGlvbnMsXG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbDogYXN5bmMgKGZ1bmN0aW9uQ2FsbFBheWxvYWQsIGNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24oZnVuY3Rpb25DYWxsUGF5bG9hZClcbiAgICpcbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICAgICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgICAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwiZnVuY3Rpb25cIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKHJlc3VsdCldLFxuICAgKiAgICAgICBmdW5jdGlvbnMsXG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgZnVuY3Rpb25DYWxsUGF5bG9hZDogRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgICBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlczogKFxuICAgICAgZnVuY3Rpb25DYWxsUmVzdWx0OiBKU09OVmFsdWUsXG4gICAgKSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICB0b29scyxcbiAgICogICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOiBhc3luYyAodG9vbENhbGxQYXlsb2FkLCBhcHBlbmRUb29sQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgIGxldCBtZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW11cbiAgICogICAgLy8gICBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSB0b29sIGNhbGxzLCBzbyB3ZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtXG4gICAqICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICogICAgIC8vIC4uLiBydW4geW91ciBjdXN0b20gbG9naWMgaGVyZVxuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlGdW5jdGlvbih0b29sLmZ1bmN0aW9uKVxuICAgKiAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwidG9vbFwiIGNhbGwgbWVzc2FnZXNcbiAgICogICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSh7dG9vbF9jYWxsX2lkOnRvb2wuaWQsIGZ1bmN0aW9uX25hbWU6dG9vbC5mdW5jdGlvbi5uYW1lLCB0b29sX2NhbGxfcmVzdWx0OnJlc3VsdH0pXG4gICAqICAgIH1cbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0xMTA2JywgLy8gb3IgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZXN1bHRzIG1lc3NhZ2VzLCBjYWxsaW5nIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSB3aXRob3V0XG4gICAqICAgICAgIC8vIGFueSBhcmd1bWVudHMgd2lsbCBqc3V0IHJldHVybiB0aGUgYWNjdW11bGF0ZWQgbWVzc2FnZXNcbiAgICogICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlcywgLi4uYXBwZW5kVG9vbENhbGxNZXNzYWdlKCldLFxuICAgKiAgICAgICB0b29scyxcbiAgICogICAgICAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gYXV0byBpcyBkZWZhdWx0LCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsPzogKFxuICAgIHRvb2xDYWxsUGF5bG9hZDogVG9vbENhbGxQYXlsb2FkLFxuICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZTogKHJlc3VsdD86IHtcbiAgICAgIHRvb2xfY2FsbF9pZDogc3RyaW5nO1xuICAgICAgZnVuY3Rpb25fbmFtZTogc3RyaW5nO1xuICAgICAgdG9vbF9jYWxsX3Jlc3VsdDogSlNPTlZhbHVlO1xuICAgIH0pID0+IENyZWF0ZU1lc3NhZ2VbXSxcbiAgKSA9PiBQcm9taXNlPFxuICAgIFJlc3BvbnNlIHwgdW5kZWZpbmVkIHwgdm9pZCB8IHN0cmluZyB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICA+O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0wyOC1MNDBcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgaWQ6IHN0cmluZztcbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVua0Nob2ljZT47XG4gIGNyZWF0ZWQ6IG51bWJlcjtcbiAgbW9kZWw6IHN0cmluZztcbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMNDMtTDQ5XG4vLyBVcGRhdGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC9mMTBjNzU3ZDgzMWQ5MDQwN2JhNDdiNDY1OWQ5Y2QzNGIxYTM1YjFkXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rQ2hvaWNlIHtcbiAgZGVsdGE6IENob2ljZURlbHRhO1xuICBmaW5pc2hfcmVhc29uOlxuICAgIHwgJ3N0b3AnXG4gICAgfCAnbGVuZ3RoJ1xuICAgIHwgJ3Rvb2xfY2FsbHMnXG4gICAgfCAnY29udGVudF9maWx0ZXInXG4gICAgfCAnZnVuY3Rpb25fY2FsbCdcbiAgICB8IG51bGw7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMTIzLUwxMzlcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIENob2ljZURlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IEZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJztcblxuICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGFUb29sQ2FsbD47XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIERlbHRhVG9vbENhbGwge1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24/OiBUb29sQ2FsbEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZT86ICdmdW5jdGlvbic7XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIFRvb2xDYWxsRnVuY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvM2VjNDNlZTc5MGEyZWI2YTBjY2RkNWYyNWZhYTIzMjUxYjBmOWI4ZS9zcmMvcmVzb3VyY2VzL2NvbXBsZXRpb25zLnRzI0wyOEMxLUw2NEMxXG4gKiBDb21wbGV0aW9ucyBBUEkuIFN0cmVhbWVkIGFuZCBub24tc3RyZWFtZWQgcmVzcG9uc2VzIGFyZSB0aGUgc2FtZS5cbiAqL1xuaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjb21wbGV0aW9uIGNob2ljZXMgdGhlIG1vZGVsIGdlbmVyYXRlZCBmb3IgdGhlIGlucHV0IHByb21wdC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENvbXBsZXRpb25DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInRleHRfY29tcGxldGlvblwiXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvblVzYWdlO1xufVxuXG5pbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBvciBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZC5cbiAgICovXG4gIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIC8vIGVkaXRlZDogUmVtb3ZlZCBDb21wbGV0aW9uQ2hvaWNlLmxvZ1Byb2JzIGFuZCByZXBsYWNlZCB3aXRoIGFueVxuICBsb2dwcm9iczogYW55IHwgbnVsbDtcblxuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgdGhlIE9wZW5BSSBzdHJlYW0gZGF0YS5cbiAqIFRoZSBwYXJzZXIgZXh0cmFjdHMgYW5kIHRyaW1zIHRleHQgY29udGVudCBmcm9tIHRoZSBKU09OIGRhdGEuIFRoaXMgcGFyc2VyXG4gKiBjYW4gaGFuZGxlIGRhdGEgZm9yIGNoYXQgb3IgY29tcGxldGlvbiBtb2RlbHMuXG4gKlxuICogQHJldHVybiB7KGRhdGE6IHN0cmluZykgPT4gc3RyaW5nIHwgdm9pZHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfX1cbiAqIEEgcGFyc2VyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBKU09OIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyB0aGUgZXh0cmFjdGVkIHRleHQgY29udGVudCxcbiAqIGEgY29tcGxleCBvYmplY3Qgd2l0aCBpc1RleHQ6IGZhbHNlIGZvciBmdW5jdGlvbi90b29sIGNhbGxzLCBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpOiAoXG4gIGRhdGE6IHN0cmluZyxcbikgPT4gc3RyaW5nIHwgdm9pZCB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0ge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIGRhdGEgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpIGFzIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTtcbn1cblxuLyoqXG4gKiBSZWFkcyBjaHVua3MgZnJvbSBPcGVuQUkncyBuZXcgU3RyZWFtYWJsZSBpbnRlcmZhY2UsIHdoaWNoIGlzIGVzc2VudGlhbGx5XG4gKiB0aGUgc2FtZSBhcyB0aGUgb2xkIFJlc3BvbnNlIGJvZHkgaW50ZXJmYWNlIHdpdGggYW4gaW5jbHVkZWQgU1NFIHBhcnNlclxuICogZG9pbmcgdGhlIHBhcnNpbmcgZm9yIHVzLlxuICovXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW06IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcykge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcblxuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAvLyBjb252ZXJ0IGNodW5rIGlmIGl0IGlzIGFuIEF6dXJlIGNoYXQgY29tcGxldGlvbi4gQXp1cmUgZG9lcyBub3QgZXhwb3NlIGFsbFxuICAgIC8vIHByb3BlcnRpZXMgaW4gdGhlIGludGVyZmFjZXMsIGFuZCBhbHNvIHVzZXMgY2FtZWxDYXNlIGluc3RlYWQgb2Ygc25ha2VfY2FzZVxuICAgIGlmICgncHJvbXB0RmlsdGVyUmVzdWx0cycgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IChjaHVuayBhcyBhbnkpLm9iamVjdCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiAoY2h1bmsgYXMgYW55KS5tb2RlbCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKGNob2ljZSA9PiAoe1xuICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICBjb250ZW50OiBjaG9pY2UuZGVsdGE/LmNvbnRlbnQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaG9pY2UuZGVsdGE/LmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgIHJvbGU6IGNob2ljZS5kZWx0YT8ucm9sZSBhcyBhbnksXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBjaG9pY2UuZGVsdGE/LnRvb2xDYWxscz8ubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24gYXMgYW55LFxuICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXgsXG4gICAgICAgIH0pKSxcbiAgICAgIH0gc2F0aXNmaWVzIENoYXRDb21wbGV0aW9uQ2h1bms7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuXG4gICAgaWYgKHRleHQpIHlpZWxkIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKTogKFxuICBjaHVuazogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pID0+IHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0gfCB2b2lkIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luOiBib29sZWFuO1xuICByZXR1cm4ganNvbiA9PiB7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhO1xuICAgICAgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/Lm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7dG9vbENhbGwuZnVuY3Rpb24/Lm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/LmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cyhkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAoanNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnZnVuY3Rpb25fY2FsbCcgfHxcbiAgICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICdzdG9wJylcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19JyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICd0b29sX2NhbGxzJ1xuICAgICAgKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfScsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnRcbiAgICAgICAgOiBpc0NvbXBsZXRpb24oanNvbilcbiAgICAgICAgPyBqc29uLmNob2ljZXNbMF0udGV4dFxuICAgICAgICA6ICcnLFxuICAgICk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bms6IHN0cmluZykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAvLyBSZXBsYWNlIGJhY2tzbGFzaGVzIGZpcnN0IHRvIHByZXZlbnQgZG91YmxlIGVzY2FwaW5nXG4gICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcLycpIC8vIEVzY2FwZSBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIC8vIEVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIC8vIEVzY2FwZSBuZXcgbGluZXNcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgLy8gRXNjYXBlIGNhcnJpYWdlIHJldHVybnNcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgLy8gRXNjYXBlIHRhYnNcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJyk7IC8vIEVzY2FwZSBmb3JtIGZlZWRzXG5cbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cblxuY29uc3QgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgJ2ludGVybmFsX29wZW5haV9mbl9tZXNzYWdlcycsXG4pO1xuXG50eXBlIEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIHwgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxuICB8IEFzeW5jSXRlcmFibGU8Q29tcGxldGlvbj5cbiAgfCBBc3luY0l0ZXJhYmxlPEF6dXJlQ2hhdENvbXBsZXRpb25zPjtcblxudHlwZSBFeHRyYWN0VHlwZTxUPiA9IFQgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGluZmVyIFU+ID8gVSA6IG5ldmVyO1xuXG50eXBlIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzID1cbiAgRXh0cmFjdFR5cGU8QXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzPjtcblxuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKFxuICBkYXRhOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbik6IGRhdGEgaXMgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIHJldHVybiAoXG4gICAgJ2Nob2ljZXMnIGluIGRhdGEgJiZcbiAgICBkYXRhLmNob2ljZXMgJiZcbiAgICBkYXRhLmNob2ljZXNbMF0gJiZcbiAgICAnZGVsdGEnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpOiBkYXRhIGlzIENvbXBsZXRpb24ge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ3RleHQnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgW09wZW5BSSBwcm92aWRlcl0oaHR0cHM6Ly9zZGsudmVyY2VsLmFpL3Byb3ZpZGVycy9haS1zZGstcHJvdmlkZXJzL29wZW5haSkgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9wZW5BSVN0cmVhbShcbiAgcmVzOiBSZXNwb25zZSB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbiAgY2FsbGJhY2tzPzogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzLFxuKTogUmVhZGFibGVTdHJlYW0ge1xuICAvLyBBbm5vdGF0ZSB0aGUgaW50ZXJuYWwgYG1lc3NhZ2VzYCBwcm9wZXJ0eSBmb3IgcmVjdXJzaXZlIGZ1bmN0aW9uIGNhbGxzXG4gIGNvbnN0IGNiOlxuICAgIHwgdW5kZWZpbmVkXG4gICAgfCAoT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0/OiBDcmVhdGVNZXNzYWdlW107XG4gICAgICB9KSA9IGNhbGxiYWNrcztcblxuICBsZXQgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PjtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICBjYj8uZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiPy5leHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgICAgb25GaW5hbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgY2I/LmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYj8uZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIG9uRmluYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoXG4gIGNhbGxiYWNrczogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXT86IENyZWF0ZU1lc3NhZ2VbXTtcbiAgfSxcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PiB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gJyc7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSAnJztcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuXG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID1cbiAgICBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG5cbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcblxuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9XG4gICAgICAgIGlzRmlyc3RDaHVuayAmJlxuICAgICAgICAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHxcbiAgICAgICAgICBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG5cbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJlYW0gYXMgbm9ybWFsXG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBtZXNzYWdlKSksXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpc0ZpcnN0Q2h1bmsgJiZcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAgICAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fFxuICAgICAgICAgICAgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKVxuICAgICAgICApIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCBtZXNzYWdlIHRvIHRoZSBsaXN0XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzOiBDcmVhdGVNZXNzYWdlW10gPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2U6XG4gICAgICAgICAgICB8IFJlc3BvbnNlXG4gICAgICAgICAgICB8IHVuZGVmaW5lZFxuICAgICAgICAgICAgfCB2b2lkXG4gICAgICAgICAgICB8IHN0cmluZ1xuICAgICAgICAgICAgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIC8vIFRoaXMgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBjaGVjayBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBidXQgVFMgY29tcGxhaW5zXG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgY2FsbGJhY2ssIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2luZyB0b29sc1xuICAgICAgICAgICAgLy8gaWYgcGF5bG9hZC5mdW5jdGlvbl9jYWxsIGlzIG5vdCBkZWZpbmVkIGJ5IHRpbWUgd2UgZ2V0IGhlcmUgd2UgbXVzdCBoYXZlIGdvdHRlbiBhIHRvb2wgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgdXNlciBoYWQgZGVmaW5lZCBleHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVxdWVzdCBhbmQgcmVzdWx0IG1lc3NhZ2VzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHM6IFRvb2xDYWxsUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlcXVlc3QgYW5kIHJlc3VsdCBtZXNzYWdlcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi4ocmVzcG9uc2VJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YzogVG9vbENhbGwpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3Rvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBpdCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBkaWRuJ3QgZG8gYW55dGhpbmcgd2l0aCB0aGUgZnVuY3Rpb24gY2FsbCBvbiB0aGUgc2VydmVyIGFuZCB3YW50c1xuICAgICAgICAgICAgLy8gdG8gZWl0aGVyIGRvIG5vdGhpbmcgb3IgcnVuIGl0IG9uIHRoZSBjbGllbnRcbiAgICAgICAgICAgIC8vIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmdW5jdGlvbiBjYWxsIGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/ICdmdW5jdGlvbl9jYWxsJyA6ICd0b29sX2NhbGxzJyxcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciByZXR1cm5lZCBhIHN0cmluZywgc28gd2UganVzdCByZXR1cm4gaXQgYXMgYSBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgZnVuY3Rpb25SZXNwb25zZSkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHk6XG5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgb25TdGFydCBvciBvbkNvbXBsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgLy8gc28gd2UgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgY2FsbGJhY2tzXG4gICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvYWkvaXNzdWVzLzM1MVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzOiBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgb25GaW5hbCB0byBiZSBjYWxsZWQgdGhlIF9sYXN0XyB0aW1lXG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgIH0gYXMgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cbiIsIi8qKlxuICogQ29uc3VtZXMgYSBSZWFkYWJsZVN0cmVhbSB1bnRpbCBpdCdzIGZ1bGx5IHJlYWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZWFkcyB0aGUgc3RyZWFtIGNodW5rIGJ5IGNodW5rIHVudGlsIHRoZSBzdHJlYW0gaXMgZXhoYXVzdGVkLlxuICogSXQgZG9lc24ndCBwcm9jZXNzIG9yIHJldHVybiB0aGUgZGF0YSBmcm9tIHRoZSBzdHJlYW07IGl0IHNpbXBseSBlbnN1cmVzXG4gKiB0aGF0IHRoZSBlbnRpcmUgc3RyZWFtIGlzIHJlYWQuXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbX0gc3RyZWFtIC0gVGhlIFJlYWRhYmxlU3RyZWFtIHRvIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHN0cmVhbSBpcyBmdWxseSBjb25zdW1lZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSBicmVhaztcbiAgfVxufVxuIiwiaW1wb3J0IHsgTGFuZ3VhZ2VNb2RlbFYxIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0JztcbmltcG9ydCB7IGdldFZhbGlkYXRlZFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0JztcbmltcG9ydCB7IHByZXBhcmVDYWxsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3Byb21wdCc7XG5pbXBvcnQgeyBDYWxsV2FybmluZywgQ29yZVRvb2xDaG9pY2UsIEZpbmlzaFJlYXNvbiB9IGZyb20gJy4uLy4uL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHtcbiAgQ29tcGxldGlvblRva2VuVXNhZ2UsXG4gIGNhbGN1bGF0ZUNvbXBsZXRpb25Ub2tlblVzYWdlLFxufSBmcm9tICcuLi8uLi9jb3JlL3R5cGVzL3Rva2VuLXVzYWdlJztcbmltcG9ydCB7IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvaW52YWxpZC10b29sLWFyZ3VtZW50cy1lcnJvcic7XG5pbXBvcnQgeyBOb1N1Y2hUb29sRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvbm8tc3VjaC10b29sLWVycm9yJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGlzQXN5bmNHZW5lcmF0b3IgfSBmcm9tICcuLi8uLi91dGlsL2lzLWFzeW5jLWdlbmVyYXRvcic7XG5pbXBvcnQgeyBpc0dlbmVyYXRvciB9IGZyb20gJy4uLy4uL3V0aWwvaXMtZ2VuZXJhdG9yJztcbmltcG9ydCB7IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJy4uLy4uL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSB9IGZyb20gJy4uL3N0cmVhbWFibGUnO1xuXG50eXBlIFN0cmVhbWFibGUgPSBSZWFjdE5vZGUgfCBQcm9taXNlPFJlYWN0Tm9kZT47XG5cbnR5cGUgUmVuZGVyZXI8VCBleHRlbmRzIEFycmF5PGFueT4+ID0gKFxuICAuLi5hcmdzOiBUXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG50eXBlIFJlbmRlclRvb2w8UEFSQU1FVEVSUyBleHRlbmRzIHouWm9kVHlwZUFueSA9IGFueT4gPSB7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBwYXJhbWV0ZXJzOiBQQVJBTUVURVJTO1xuICBnZW5lcmF0ZT86IFJlbmRlcmVyPFxuICAgIFtcbiAgICAgIHouaW5mZXI8UEFSQU1FVEVSUz4sXG4gICAgICB7XG4gICAgICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHN0cmluZztcbiAgICAgIH0sXG4gICAgXVxuICA+O1xufTtcblxudHlwZSBSZW5kZXJUZXh0ID0gUmVuZGVyZXI8XG4gIFtcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmdWxsIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzbyBmYXIuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmV3IGFwcGVuZGVkIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzaW5jZSB0aGUgbGFzdCBgdGV4dGAgY2FsbC5cbiAgICAgICAqL1xuICAgICAgZGVsdGE6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgICAqIElmIGB0cnVlYCwgdGhlIGBjb250ZW50YCB3aWxsIGJlIHRoZSBmaW5hbCBvdXRwdXQgYW5kIHRoaXMgY2FsbCB3aWxsIGJlIHRoZSBsYXN0LlxuICAgICAgICovXG4gICAgICBkb25lOiBib29sZWFuO1xuICAgIH0sXG4gIF1cbj47XG5cbnR5cGUgUmVuZGVyUmVzdWx0ID0ge1xuICB2YWx1ZTogUmVhY3ROb2RlO1xufSAmIEF3YWl0ZWQ8UmV0dXJuVHlwZTxMYW5ndWFnZU1vZGVsVjFbJ2RvU3RyZWFtJ10+PjtcblxuY29uc3QgZGVmYXVsdFRleHRSZW5kZXJlcjogUmVuZGVyVGV4dCA9ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT5cbiAgY29udGVudDtcblxuLyoqXG4gKiBgc3RyZWFtVUlgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBMTE1zLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVUk8XG4gIFRPT0xTIGV4dGVuZHMgeyBbbmFtZTogc3RyaW5nXTogei5ab2RUeXBlQW55IH0gPSB7fSxcbj4oe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGluaXRpYWwsXG4gIHRleHQsXG4gIG9uRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufTogQ2FsbFNldHRpbmdzICZcbiAgUHJvbXB0ICYge1xuICAgIC8qKlxuICAgICAqIFRoZSBsYW5ndWFnZSBtb2RlbCB0byB1c2UuXG4gICAgICovXG4gICAgbW9kZWw6IExhbmd1YWdlTW9kZWxWMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29scyB0aGF0IHRoZSBtb2RlbCBjYW4gY2FsbC4gVGhlIG1vZGVsIG5lZWRzIHRvIHN1cHBvcnQgY2FsbGluZyB0b29scy5cbiAgICAgKi9cbiAgICB0b29scz86IHtcbiAgICAgIFtuYW1lIGluIGtleW9mIFRPT0xTXTogUmVuZGVyVG9vbDxUT09MU1tuYW1lXT47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29sIGNob2ljZSBzdHJhdGVneS4gRGVmYXVsdDogJ2F1dG8nLlxuICAgICAqL1xuICAgIHRvb2xDaG9pY2U/OiBDb3JlVG9vbENob2ljZTxUT09MUz47XG5cbiAgICB0ZXh0PzogUmVuZGVyVGV4dDtcbiAgICBpbml0aWFsPzogUmVhY3ROb2RlO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIExMTSByZXNwb25zZSBhbmQgdGhlIGZpbmFsIG9iamVjdCB2YWxpZGF0aW9uIGFyZSBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBvbkZpbmlzaD86IChldmVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcmVhc29uIHdoeSB0aGUgZ2VuZXJhdGlvbiBmaW5pc2hlZC5cbiAgICAgICAqL1xuICAgICAgZmluaXNoUmVhc29uOiBGaW5pc2hSZWFzb247XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b2tlbiB1c2FnZSBvZiB0aGUgZ2VuZXJhdGVkIHJlc3BvbnNlLlxuICAgICAgICovXG4gICAgICB1c2FnZTogQ29tcGxldGlvblRva2VuVXNhZ2U7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmaW5hbCB1aSBub2RlIHRoYXQgd2FzIGdlbmVyYXRlZC5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IFJlYWN0Tm9kZTtcbiAgICAgIC8qKlxuICAgICAgICogV2FybmluZ3MgZnJvbSB0aGUgbW9kZWwgcHJvdmlkZXIgKGUuZy4gdW5zdXBwb3J0ZWQgc2V0dGluZ3MpXG4gICAgICAgKi9cbiAgICAgIHdhcm5pbmdzPzogQ2FsbFdhcm5pbmdbXTtcbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9uYWwgcmF3IHJlc3BvbnNlIGRhdGEuXG4gICAgICAgKi9cbiAgICAgIHJhd1Jlc3BvbnNlPzoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzcG9uc2UgaGVhZGVycy5cbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgfTtcbiAgICB9KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgfSk6IFByb21pc2U8UmVuZGVyUmVzdWx0PiB7XG4gIC8vIFRPRE86IFJlbW92ZSB0aGVzZSBlcnJvcnMgYWZ0ZXIgdGhlIGV4cGVyaW1lbnRhbCBwaGFzZS5cbiAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYG1vZGVsYCBjYW5ub3QgYmUgYSBzdHJpbmcgaW4gYHN0cmVhbVVJYC4gVXNlIHRoZSBhY3R1YWwgbW9kZWwgaW5zdGFuY2UgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdmdW5jdGlvbnMnIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2BmdW5jdGlvbnNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYHN0cmVhbVVJYCwgdXNlIGB0b29sc2AgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdwcm92aWRlcicgaW4gc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYHByb3ZpZGVyYCBpcyBubyBsb25nZXIgbmVlZGVkIGluIGBzdHJlYW1VSWAuIFVzZSBgbW9kZWxgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIE9iamVjdC5lbnRyaWVzKHRvb2xzKSkge1xuICAgICAgaWYgKCdyZW5kZXInIGluIHRvb2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUb29sIGRlZmluaXRpb24gaW4gYHN0cmVhbVVJYCBzaG91bGQgbm90IGhhdmUgYHJlbmRlcmAgcHJvcGVydHkuIFVzZSBgZ2VuZXJhdGVgIGluc3RlYWQuIEZvdW5kIGluIHRvb2w6ICcgK1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsKTtcblxuICAvLyBUaGUgZGVmYXVsdCB0ZXh0IHJlbmRlcmVyIGp1c3QgcmV0dXJucyB0aGUgY29udGVudCBhcyBzdHJpbmcuXG4gIGNvbnN0IHRleHRSZW5kZXIgPSB0ZXh0IHx8IGRlZmF1bHRUZXh0UmVuZGVyZXI7XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7XG4gICAgYXJncyxcbiAgICByZW5kZXJlcixcbiAgICBzdHJlYW1hYmxlVUksXG4gICAgaXNMYXN0Q2FsbCA9IGZhbHNlLFxuICB9OiB7XG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT47XG4gICAgYXJnczogW3BheWxvYWQ6IGFueV0gfCBbcGF5bG9hZDogYW55LCBvcHRpb25zOiBhbnldO1xuICAgIHN0cmVhbWFibGVVSTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RyZWFtYWJsZVVJPjtcbiAgICBpc0xhc3RDYWxsPzogYm9vbGVhbjtcbiAgfSkge1xuICAgIGlmICghcmVuZGVyZXIpIHJldHVybjtcblxuICAgIC8vIGNyZWF0ZSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHJlbmRlciBjYWxsIGlzIGZpbmlzaGVkLlxuICAgIC8vIGl0IGlzIGFwcGVuZGVkIHRvIHRoZSBgZmluaXNoZWRgIHByb21pc2UgY2hhaW4gdG8gZW5zdXJlIHRoZSByZW5kZXIgY2FsbFxuICAgIC8vIGlzIGZpbmlzaGVkIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgY2FsbCBzdGFydHMuXG4gICAgY29uc3QgcmVuZGVyRmluaXNoZWQgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTx2b2lkPigpO1xuICAgIGZpbmlzaGVkID0gZmluaXNoZWRcbiAgICAgID8gZmluaXNoZWQudGhlbigoKSA9PiByZW5kZXJGaW5pc2hlZC5wcm9taXNlKVxuICAgICAgOiByZW5kZXJGaW5pc2hlZC5wcm9taXNlO1xuXG4gICAgY29uc3QgcmVuZGVyZXJSZXN1bHQgPSByZW5kZXJlciguLi5hcmdzKTtcblxuICAgIGlmIChpc0FzeW5jR2VuZXJhdG9yKHJlbmRlcmVyUmVzdWx0KSB8fCBpc0dlbmVyYXRvcihyZW5kZXJlclJlc3VsdCkpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlbmRlcmVyUmVzdWx0Lm5leHQoKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc0xhc3RDYWxsICYmIGRvbmUpIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVUkuZG9uZShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVUkudXBkYXRlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgcmVuZGVyZXJSZXN1bHQ7XG5cbiAgICAgIGlmIChpc0xhc3RDYWxsKSB7XG4gICAgICAgIHN0cmVhbWFibGVVSS5kb25lKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtYWJsZVVJLnVwZGF0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIHRvIHNpZ25hbCB0aGF0IHRoZSByZW5kZXIgY2FsbCBpcyBmaW5pc2hlZFxuICAgIHJlbmRlckZpbmlzaGVkLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShhc3luYyAoKSA9PlxuICAgIG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInLFxuICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSksXG4gICAgICB9LFxuICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICB9KSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICB9KSxcbiAgKTtcblxuICAvLyBGb3IgdGhlIHN0cmVhbSBhbmQgY29uc3VtZSBpdCBhc3luY2hyb25vdXNseTpcbiAgY29uc3QgW3N0cmVhbSwgZm9ya2VkU3RyZWFtXSA9IHJlc3VsdC5zdHJlYW0udGVlKCk7XG4gIChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICBsZXQgaGFzVG9vbENhbGwgPSBmYWxzZTtcblxuICAgICAgY29uc3QgcmVhZGVyID0gZm9ya2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3RleHQtZGVsdGEnOiB7XG4gICAgICAgICAgICBjb250ZW50ICs9IHZhbHVlLnRleHREZWx0YTtcbiAgICAgICAgICAgIHJlbmRlcih7XG4gICAgICAgICAgICAgIHJlbmRlcmVyOiB0ZXh0UmVuZGVyLFxuICAgICAgICAgICAgICBhcmdzOiBbeyBjb250ZW50LCBkb25lOiBmYWxzZSwgZGVsdGE6IHZhbHVlLnRleHREZWx0YSB9XSxcbiAgICAgICAgICAgICAgc3RyZWFtYWJsZVVJOiB1aSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndG9vbC1jYWxsLWRlbHRhJzoge1xuICAgICAgICAgICAgaGFzVG9vbENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndG9vbC1jYWxsJzoge1xuICAgICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSB2YWx1ZS50b29sTmFtZSBhcyBrZXlvZiBUT09MUyAmIHN0cmluZztcblxuICAgICAgICAgICAgaWYgKCF0b29scykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRvb2wpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc1Rvb2xDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgIHNjaGVtYTogdG9vbC5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgdG9vbEFyZ3M6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyKHtcbiAgICAgICAgICAgICAgcmVuZGVyZXI6IHRvb2wuZ2VuZXJhdGUsXG4gICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgc3RyZWFtYWJsZVVJOiB1aSxcbiAgICAgICAgICAgICAgaXNMYXN0Q2FsbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlLmVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZpbmlzaCc6IHtcbiAgICAgICAgICAgIG9uRmluaXNoPy4oe1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUNvbXBsZXRpb25Ub2tlblVzYWdlKHZhbHVlLnVzYWdlKSxcbiAgICAgICAgICAgICAgdmFsdWU6IHVpLnZhbHVlLFxuICAgICAgICAgICAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgICAgICAgICAgICByYXdSZXNwb25zZTogcmVzdWx0LnJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzVG9vbENhbGwpIHtcbiAgICAgICAgcmVuZGVyKHtcbiAgICAgICAgICByZW5kZXJlcjogdGV4dFJlbmRlcixcbiAgICAgICAgICBhcmdzOiBbeyBjb250ZW50LCBkb25lOiB0cnVlIH1dLFxuICAgICAgICAgIHN0cmVhbWFibGVVSTogdWksXG4gICAgICAgICAgaXNMYXN0Q2FsbDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBEdXJpbmcgdGhlIHN0cmVhbSByZW5kZXJpbmcsIHdlIGRvbid0IHdhbnQgdG8gdGhyb3cgdGhlIGVycm9yIHRvIHRoZVxuICAgICAgLy8gcGFyZW50IHNjb3BlIGJ1dCBvbmx5IGxldCB0aGUgUmVhY3QncyBlcnJvciBib3VuZGFyeSB0byBjYXRjaCBpdC5cbiAgICAgIHVpLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN1bHQsXG4gICAgc3RyZWFtLFxuICAgIHZhbHVlOiB1aS52YWx1ZSxcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jR2VuZXJhdG9yPFQsIFRSZXR1cm4sIFROZXh0PihcbiAgdmFsdWU6IHVua25vd24sXG4pOiB2YWx1ZSBpcyBBc3luY0dlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4ge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICApO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzR2VuZXJhdG9yPFQsIFRSZXR1cm4sIFROZXh0PihcbiAgdmFsdWU6IHVua25vd24sXG4pOiB2YWx1ZSBpcyBHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+IHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWU7XG59XG4iLCIvLyBUaGlzIGZpbGUgcHJvdmlkZXMgdGhlIEFJIGNvbnRleHQgdG8gYWxsIEFJIEFjdGlvbnMgdmlhIEFzeW5jTG9jYWxTdG9yYWdlLlxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJbnRlcm5hbEFJUHJvdmlkZXIgfSBmcm9tICcuL3JzYy1zaGFyZWQubWpzJztcbmltcG9ydCB7XG4gIHdpdGhBSVN0YXRlLFxuICBnZXRBSVN0YXRlRGVsdGFQcm9taXNlLFxuICBzZWFsTXV0YWJsZUFJU3RhdGUsXG59IGZyb20gJy4vYWktc3RhdGUnO1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyxcbiAgQUlBY3Rpb24sXG4gIEFJQWN0aW9ucyxcbiAgQUlQcm92aWRlcixcbiAgSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4gIE9uU2V0QUlTdGF0ZSxcbiAgT25HZXRVSVN0YXRlLFxufSBmcm9tICcuL3R5cGVzJztcblxuYXN5bmMgZnVuY3Rpb24gaW5uZXJBY3Rpb248VD4oXG4gIHtcbiAgICBhY3Rpb24sXG4gICAgb3B0aW9ucyxcbiAgfTogeyBhY3Rpb246IEFJQWN0aW9uOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBzdGF0ZTogVCxcbiAgLi4uYXJnczogdW5rbm93bltdXG4pIHtcbiAgJ3VzZSBzZXJ2ZXInO1xuICByZXR1cm4gYXdhaXQgd2l0aEFJU3RhdGUoXG4gICAge1xuICAgICAgc3RhdGUsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgc2VhbE11dGFibGVBSVN0YXRlKCk7XG4gICAgICByZXR1cm4gW2dldEFJU3RhdGVEZWx0YVByb21pc2UoKSBhcyBQcm9taXNlPFQ+LCByZXN1bHRdO1xuICAgIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb248VCA9IHVua25vd24+KFxuICBhY3Rpb246IEFJQWN0aW9uLFxuICBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbikge1xuICByZXR1cm4gaW5uZXJBY3Rpb24uYmluZChudWxsLCB7IGFjdGlvbiwgb3B0aW9ucyB9KSBhcyBBSUFjdGlvbjxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFJPFxuICBBSVN0YXRlID0gYW55LFxuICBVSVN0YXRlID0gYW55LFxuICBBY3Rpb25zIGV4dGVuZHMgQUlBY3Rpb25zID0ge30sXG4+KHtcbiAgYWN0aW9ucyxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxVSVN0YXRlLFxuXG4gIG9uU2V0QUlTdGF0ZSxcbiAgb25HZXRVSVN0YXRlLFxufToge1xuICBhY3Rpb25zOiBBY3Rpb25zO1xuICBpbml0aWFsQUlTdGF0ZT86IEFJU3RhdGU7XG4gIGluaXRpYWxVSVN0YXRlPzogVUlTdGF0ZTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIEFJIHN0YXRlIGlzIHVwZGF0ZWQgYnkgYW4gQWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRvIHBlcnNpc3QgdGhlIEFJIHN0YXRlIHRvIGEgZGF0YWJhc2UsIG9yIHRvIHNlbmQgaXQgdG8gYVxuICAgKiBsb2dnaW5nIHNlcnZpY2UuXG4gICAqL1xuICBvblNldEFJU3RhdGU/OiBPblNldEFJU3RhdGU8QUlTdGF0ZT47XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgVUkgc3RhdGUgYmFzZWQgb24gdGhlIEFJIHN0YXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gcmVuZGVyIHRoZSBpbml0aWFsIFVJIHN0YXRlIGJhc2VkIG9uIGEgZ2l2ZW4gQUkgc3RhdGUsIG9yXG4gICAqIHRvIHN5bmMgdGhlIFVJIHN0YXRlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIGFscmVhZHkgbG9hZGVkLlxuICAgKlxuICAgKiBJZiByZXR1cm5pbmcgYHVuZGVmaW5lZGAsIHRoZSBjbGllbnQgc2lkZSBVSSBzdGF0ZSB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgYW5ub3RhdGVkIHdpdGggdGhlIGBcInVzZSBzZXJ2ZXJcImAgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogb25HZXRVSVN0YXRlOiBhc3luYyAoKSA9PiB7XG4gICAqICAgJ3VzZSBzZXJ2ZXInO1xuICAgKlxuICAgKiAgIGNvbnN0IGN1cnJlbnRBSVN0YXRlID0gZ2V0QUlTdGF0ZSgpO1xuICAgKiAgIGNvbnN0IGV4dGVybmFsQUlTdGF0ZSA9IGF3YWl0IGxvYWRBSVN0YXRlRnJvbURhdGFiYXNlKCk7XG4gICAqXG4gICAqICAgaWYgKGN1cnJlbnRBSVN0YXRlID09PSBleHRlcm5hbEFJU3RhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAqXG4gICAqICAgLy8gVXBkYXRlIGN1cnJlbnQgQUkgc3RhdGUgYW5kIHJldHVybiB0aGUgbmV3IFVJIHN0YXRlXG4gICAqICAgY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gICAqICAgc3RhdGUuZG9uZShleHRlcm5hbEFJU3RhdGUpXG4gICAqXG4gICAqICAgcmV0dXJuIDxkaXY+Li4uPC9kaXY+O1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb25HZXRVSVN0YXRlPzogT25HZXRVSVN0YXRlPFVJU3RhdGU+O1xufSkge1xuICAvLyBXcmFwIGFsbCBhY3Rpb25zIHdpdGggb3VyIEhvQy5cbiAgY29uc3Qgd3JhcHBlZEFjdGlvbnM6IFNlcnZlcldyYXBwZWRBY3Rpb25zID0ge307XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgd3JhcHBlZEFjdGlvbnNbbmFtZV0gPSB3cmFwQWN0aW9uKGFjdGlvbnNbbmFtZV0sIHtcbiAgICAgIG9uU2V0QUlTdGF0ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHdyYXBwZWRTeW5jVUlTdGF0ZSA9IG9uR2V0VUlTdGF0ZVxuICAgID8gd3JhcEFjdGlvbihvbkdldFVJU3RhdGUsIHt9KVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IEFJOiBBSVByb3ZpZGVyPEFJU3RhdGUsIFVJU3RhdGUsIEFjdGlvbnM+ID0gYXN5bmMgcHJvcHMgPT4ge1xuICAgIGlmICgndXNlU3RhdGUnIGluIFJlYWN0KSB7XG4gICAgICAvLyBUaGlzIGZpbGUgbXVzdCBiZSBydW5uaW5nIG9uIHRoZSBSZWFjdCBTZXJ2ZXIgbGF5ZXIuXG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCBiZSB1c2luZyBgaW1wb3J0IFwic2VydmVyLW9ubHlcImAgaGVyZSBidXQgd2UgY2FuIGhhdmUgYVxuICAgICAgLy8gbW9yZSBjdXN0b21pemVkIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgU2VydmVyIENvbXBvbmVudHMuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHVpU3RhdGUgPSBwcm9wcy5pbml0aWFsVUlTdGF0ZSA/PyBpbml0aWFsVUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZSA9IHByb3BzLmluaXRpYWxBSVN0YXRlID8/IGluaXRpYWxBSVN0YXRlO1xuICAgIGxldCBhaVN0YXRlRGVsdGEgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAod3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICBjb25zdCBbbmV3QUlTdGF0ZURlbHRhLCBuZXdVSVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZShhaVN0YXRlKTtcbiAgICAgIGlmIChuZXdVSVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWlTdGF0ZURlbHRhID0gbmV3QUlTdGF0ZURlbHRhO1xuICAgICAgICB1aVN0YXRlID0gbmV3VUlTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEludGVybmFsQUlQcm92aWRlclxuICAgICAgICB3cmFwcGVkQWN0aW9ucz17d3JhcHBlZEFjdGlvbnN9XG4gICAgICAgIHdyYXBwZWRTeW5jVUlTdGF0ZT17d3JhcHBlZFN5bmNVSVN0YXRlfVxuICAgICAgICBpbml0aWFsVUlTdGF0ZT17dWlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbEFJU3RhdGU9e2FpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlUGF0Y2g9e2FpU3RhdGVEZWx0YX1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9JbnRlcm5hbEFJUHJvdmlkZXI+XG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gQUk7XG59XG4iXSwibmFtZXMiOlsianNvbmRpZmZwYXRjaCIsIkFzeW5jTG9jYWxTdG9yYWdlIiwiY3JlYXRlUmVzb2x2YWJsZVByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJpc0Z1bmN0aW9uIiwidmFsdWUiLCJhc3luY0FJU3RhdGVTdG9yYWdlIiwiZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyIsIm1lc3NhZ2UiLCJzdG9yZSIsImdldFN0b3JlIiwiRXJyb3IiLCJ3aXRoQUlTdGF0ZSIsInN0YXRlIiwib3B0aW9ucyIsImZuIiwicnVuIiwiY3VycmVudFN0YXRlIiwib3JpZ2luYWxTdGF0ZSIsInNlYWxlZCIsImdldEFJU3RhdGVEZWx0YVByb21pc2UiLCJtdXRhdGlvbkRlbHRhUHJvbWlzZSIsInNlYWxNdXRhYmxlQUlTdGF0ZSIsImdldEFJU3RhdGUiLCJhcmdzIiwibGVuZ3RoIiwia2V5IiwiU3RyaW5nIiwiZ2V0TXV0YWJsZUFJU3RhdGUiLCJtdXRhdGlvbkRlbHRhUmVzb2x2ZSIsImRvVXBkYXRlIiwibmV3U3RhdGUiLCJkb25lIiwiX2EiLCJfYiIsIm9uU2V0QUlTdGF0ZSIsImNhbGwiLCJtdXRhYmxlU3RhdGUiLCJnZXQiLCJ1cGRhdGUiLCJuZXdBSVN0YXRlIiwiZG9uZUFyZ3MiLCJkZWx0YSIsImRpZmYiLCJTVFJFQU1BQkxFX1ZBTFVFX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSIsIlN1c3BlbnNlIiwiRnJhZ21lbnQiLCJqc3giLCJqc3hzIiwiUiIsImMiLCJjdXJyZW50IiwibiIsIm5leHQiLCJjaHVuayIsImFwcGVuZCIsImNoaWxkcmVuIiwiZmFsbGJhY2siLCJjcmVhdGVTdXNwZW5kZWRDaHVuayIsImluaXRpYWxWYWx1ZSIsInJvdyIsImNyZWF0ZVN0cmVhbWFibGVVSSIsImN1cnJlbnRWYWx1ZSIsImNsb3NlZCIsImFzc2VydFN0cmVhbSIsIm1ldGhvZCIsIndhcm5pbmdUaW1lb3V0Iiwid2FyblVuY2xvc2VkU3RyZWFtIiwicHJvY2VzcyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjb25zb2xlIiwid2FybiIsInN0cmVhbWFibGUiLCJyZXNvbHZhYmxlIiwiZXJyb3IiLCJTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0siLCJjcmVhdGVTdHJlYW1hYmxlVmFsdWUiLCJpc1JlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJnZXRSZWFkZXIiLCJsb2NrZWQiLCJjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsIiwic3RyZWFtYWJsZVZhbHVlIiwicmVhZGVyIiwicmVhZCIsImUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UHJvbWlzZSIsImN1cnJlbnRQYXRjaFZhbHVlIiwiY3JlYXRlV3JhcHBlZCIsImluaXRpYWxDaHVuayIsImluaXQiLCJjdXJyIiwidHlwZSIsInVwZGF0ZVZhbHVlU3RhdGVzIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicmVzb2x2ZVByZXZpb3VzIiwiem9kVG9Kc29uU2NoZW1hIiwiQVBJQ2FsbEVycm9yIiwiZ2V0RXJyb3JNZXNzYWdlIiwiaXNBYm9ydEVycm9yIiwiZGVsYXkiLCJkZWxheUluTXMiLCJBSVNES0Vycm9yIiwibmFtZSIsIm1hcmtlciIsInN5bWJvbCIsIlJldHJ5RXJyb3IiLCJjb25zdHJ1Y3RvciIsInJlYXNvbiIsImVycm9ycyIsImxhc3RFcnJvciIsImlzSW5zdGFuY2UiLCJoYXNNYXJrZXIiLCJpc1JldHJ5RXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJ0b0pTT04iLCJyZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJtYXhSZXRyaWVzIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9yTWVzc2FnZSIsIm5ld0Vycm9ycyIsInRyeU51bWJlciIsImlzQVBJQ2FsbEVycm9yIiwiaXNSZXRyeWFibGUiLCJEb3dubG9hZEVycm9yIiwidXJsIiwic3RhdHVzQ29kZSIsInN0YXR1c1RleHQiLCJjYXVzZSIsImlzRG93bmxvYWRFcnJvciIsImRvd25sb2FkIiwiZmV0Y2hJbXBsZW1lbnRhdGlvbiIsImZldGNoIiwidXJsVGV4dCIsInRvU3RyaW5nIiwicmVzcG9uc2UiLCJvayIsInN0YXR1cyIsImRhdGEiLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJtaW1lVHlwZSIsImhlYWRlcnMiLCJtaW1lVHlwZVNpZ25hdHVyZXMiLCJieXRlcyIsImRldGVjdEltYWdlTWltZVR5cGUiLCJpbWFnZSIsImV2ZXJ5IiwiYnl0ZSIsImluZGV4IiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciIsImNvbnRlbnQiLCJpc0ludmFsaWREYXRhQ29udGVudEVycm9yIiwic3RhY2siLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJBcnJheUJ1ZmZlciIsIkludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwicm9sZSIsImlzSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IiwicHJvbXB0IiwibW9kZWxTdXBwb3J0c0ltYWdlVXJscyIsImRvd25sb2FkSW1wbGVtZW50YXRpb24iLCJsYW5ndWFnZU1vZGVsTWVzc2FnZXMiLCJzeXN0ZW0iLCJwdXNoIiwiZG93bmxvYWRlZEltYWdlcyIsIm1lc3NhZ2VzIiwiZG93bmxvYWRJbWFnZXMiLCJwcm9tcHRUeXBlIiwidGV4dCIsIm1hcCIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlIiwiX2V4aGF1c3RpdmVDaGVjayIsInBhcnQiLCJfYyIsIlVSTCIsImRvd25sb2FkZWRJbWFnZSIsInByb3RvY29sIiwiaGVhZGVyIiwiYmFzZTY0Q29udGVudCIsInNwbGl0IiwiX2lnbm9yZWQiLCJpbWFnZVVpbnQ4IiwiZmlsdGVyIiwidXJscyIsImZsYXQiLCJhbGwiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsIkludmFsaWRQcm9tcHRFcnJvciIsImdldFZhbGlkYXRlZFByb21wdCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicGFyYW1ldGVyIiwiaXNJbnZhbGlkQXJndW1lbnRFcnJvciIsInByZXBhcmVDYWxsU2V0dGluZ3MiLCJtYXhUb2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInRvcFAiLCJwcmVzZW5jZVBlbmFsdHkiLCJmcmVxdWVuY3lQZW5hbHR5Iiwic3RvcFNlcXVlbmNlcyIsInNlZWQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJjYWxjdWxhdGVDb21wbGV0aW9uVG9rZW5Vc2FnZSIsInVzYWdlIiwicHJvbXB0VG9rZW5zIiwiY29tcGxldGlvblRva2VucyIsInRvdGFsVG9rZW5zIiwidmFsaWRhdG9yU3ltYm9sIiwic2NoZW1hU3ltYm9sIiwianNvblNjaGVtYSIsInZhbGlkYXRlIiwiX3R5cGUiLCJpc1NjaGVtYSIsImFzU2NoZW1hIiwic2NoZW1hIiwiem9kU2NoZW1hIiwicmVzdWx0Iiwic2FmZVBhcnNlIiwic3VjY2VzcyIsImlzTm9uRW1wdHlPYmplY3QiLCJvYmplY3QiLCJrZXlzIiwicHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSIsInRvb2xzIiwidG9vbENob2ljZSIsImVudHJpZXMiLCJ0b29sIiwiZGVzY3JpcHRpb24iLCJwYXJhbWV0ZXJzIiwidG9vbE5hbWUiLCJJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIiwidG9vbEFyZ3MiLCJpc0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3IiLCJOb1N1Y2hUb29sRXJyb3IiLCJhdmFpbGFibGVUb29scyIsImpvaW4iLCJpc05vU3VjaFRvb2xFcnJvciIsImNyZWF0ZVBhcnNlciIsImNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIiLCJjdXN0b21QYXJzZXIiLCJ0ZXh0RGVjb2RlciIsIlRleHREZWNvZGVyIiwiZXZlbnRTb3VyY2VQYXJzZXIiLCJUcmFuc2Zvcm1TdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJldmVudCIsInRlcm1pbmF0ZSIsInBhcnNlZE1lc3NhZ2UiLCJlbnF1ZXVlIiwidHJhbnNmb3JtIiwiZmVlZCIsImRlY29kZSIsImNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyIiwiY2IiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tzIiwib25TdGFydCIsImVuY29kZSIsIm9uVG9rZW4iLCJvblRleHQiLCJmbHVzaCIsImlzT3BlbkFJQ2FsbGJhY2tzIiwiaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MiLCJvbkNvbXBsZXRpb24iLCJvbkZpbmFsIiwidHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIiLCJpc1N0cmVhbVN0YXJ0IiwidHJpbVN0YXJ0IiwiQUlTdHJlYW0iLCJib2R5IiwiZXJyb3JUZXh0IiwicmVzcG9uc2VCb2R5U3RyZWFtIiwiY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSIsInBpcGVUaHJvdWdoIiwiY2xvc2UiLCJyZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlIiwiaXRlcmFibGUiLCJpdCIsImFzeW5jSXRlcmF0b3IiLCJwdWxsIiwiY2FuY2VsIiwicmV0dXJuIiwiZm9ybWF0U3RyZWFtUGFydCIsIlNUUkVBTV9EQVRBX1dBUk5JTkdfVElNRV9NUyIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImVuY29kZXIiLCJkZWNvZGVyIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwicGFyc2VPcGVuQUlTdHJlYW0iLCJleHRyYWN0IiwiY2h1bmtUb1RleHQiLCJKU09OIiwicGFyc2UiLCJzdHJlYW0iLCJpZCIsImNyZWF0ZWQiLCJnZXREYXRlIiwibW9kZWwiLCJjaG9pY2VzIiwiY2hvaWNlIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJmdW5jdGlvbl9jYWxsIiwiZnVuY3Rpb25DYWxsIiwidG9vbF9jYWxscyIsInRvb2xDYWxscyIsInRvb2xDYWxsIiwiZnVuY3Rpb24iLCJmaW5pc2hfcmVhc29uIiwiZmluaXNoUmVhc29uIiwidHJpbVN0YXJ0T2ZTdHJlYW0iLCJpc0Z1bmN0aW9uU3RyZWFtaW5nSW4iLCJqc29uIiwiX2giLCJfaSIsIl9qIiwiX2siLCJfbCIsIl9tIiwiX24iLCJfbyIsIl9wIiwiX3EiLCJfciIsImlzQ2hhdENvbXBsZXRpb25DaHVuayIsImlzVGV4dCIsImFyZ3VtZW50cyIsImNsZWFudXBBcmd1bWVudHMiLCJpc0NvbXBsZXRpb24iLCJhcmd1bWVudENodW5rIiwiZXNjYXBlZFBhcnRpYWxKc29uIiwicmVwbGFjZSIsIl9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wiLCJPcGVuQUlTdHJlYW0iLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCIsImZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJpc0ZpcnN0Q2h1bmsiLCJhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UiLCJmdW5jdGlvbkNhbGxNZXNzYWdlcyIsInNob3VsZEhhbmRsZUFzRnVuY3Rpb24iLCJwYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwiYXJndW1lbnRzUGF5bG9hZCIsInN0cmluZ2lmeSIsImZ1bmMiLCJyZXNwb25zZUluZGV4IiwidG9vbF9jYWxsX2lkIiwiZnVuY3Rpb25fbmFtZSIsInRvb2xfY2FsbF9yZXN1bHQiLCJ0YyIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiY29uc3VtZVN0cmVhbSIsInJlbmRlciIsInVpIiwiaW5pdGlhbCIsImZ1bmN0aW9ucyIsImZpbmlzaGVkIiwiaGFuZGxlUmVuZGVyIiwicmVuZGVyZXIiLCJ0aGVuIiwibm9kZSIsIml0ZXJhdG9yIiwiaGFzRnVuY3Rpb24iLCJwcm92aWRlciIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsImZ1bmN0aW9uQ2FsbFBheWxvYWQiLCJ0b29sQ2FsbFBheWxvYWQiLCJzYWZlUGFyc2VKU09OIiwiaXNBc3luY0dlbmVyYXRvciIsImlzR2VuZXJhdG9yIiwiZGVmYXVsdFRleHRSZW5kZXJlciIsInN0cmVhbVVJIiwiYWJvcnRTaWduYWwiLCJvbkZpbmlzaCIsInNldHRpbmdzIiwidGV4dFJlbmRlciIsInN0cmVhbWFibGVVSSIsImlzTGFzdENhbGwiLCJyZW5kZXJGaW5pc2hlZCIsInJlbmRlcmVyUmVzdWx0IiwicmV0cnkiLCJ2YWxpZGF0ZWRQcm9tcHQiLCJkb1N0cmVhbSIsIm1vZGUiLCJpbnB1dEZvcm1hdCIsInN1cHBvcnRzSW1hZ2VVcmxzIiwiZm9ya2VkU3RyZWFtIiwidGVlIiwiaGFzVG9vbENhbGwiLCJ0ZXh0RGVsdGEiLCJwYXJzZVJlc3VsdCIsImdlbmVyYXRlIiwidG9vbENhbGxJZCIsIndhcm5pbmdzIiwicmF3UmVzcG9uc2UiLCJSZWFjdCIsIkludGVybmFsQUlQcm92aWRlciIsImlubmVyQWN0aW9uIiwiYWN0aW9uIiwid3JhcEFjdGlvbiIsImJpbmQiLCJjcmVhdGVBSSIsImFjdGlvbnMiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxVSVN0YXRlIiwib25HZXRVSVN0YXRlIiwid3JhcHBlZEFjdGlvbnMiLCJ3cmFwcGVkU3luY1VJU3RhdGUiLCJBSSIsInByb3BzIiwidWlTdGF0ZSIsImFpU3RhdGUiLCJhaVN0YXRlRGVsdGEiLCJuZXdBSVN0YXRlRGVsdGEiLCJuZXdVSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGVQYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(action-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\users\perez\onedrive\apps\desktop\DEV\AI\vmaifoundation\ask_doc\node_modules\ai\rsc\dist\rsc-shared.mjs#useUIState`);


/***/ })

};
;